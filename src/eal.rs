/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const RTE_ARCH_X86: u32 = 1;
pub const RTE_ARCH_X86_64: u32 = 1;
pub const RTE_BASEBAND_ACC: u32 = 1;
pub const RTE_BASEBAND_FPGA_5GNR_FEC: u32 = 1;
pub const RTE_BASEBAND_FPGA_LTE_FEC: u32 = 1;
pub const RTE_BASEBAND_LA12XX: u32 = 1;
pub const RTE_BASEBAND_NULL: u32 = 1;
pub const RTE_BASEBAND_TURBO_SW: u32 = 1;
pub const RTE_BUS_AUXILIARY: u32 = 1;
pub const RTE_BUS_CDX: u32 = 1;
pub const RTE_BUS_DPAA: u32 = 1;
pub const RTE_BUS_FSLMC: u32 = 1;
pub const RTE_BUS_IFPGA: u32 = 1;
pub const RTE_BUS_PCI: u32 = 1;
pub const RTE_BUS_PLATFORM: u32 = 1;
pub const RTE_BUS_VDEV: u32 = 1;
pub const RTE_BUS_VMBUS: u32 = 1;
pub const RTE_CACHE_LINE_SIZE: u32 = 64;
pub const RTE_COMMON_CNXK: u32 = 1;
pub const RTE_COMMON_CPT: u32 = 1;
pub const RTE_COMMON_DPAAX: u32 = 1;
pub const RTE_COMMON_IAVF: u32 = 1;
pub const RTE_COMMON_IDPF: u32 = 1;
pub const RTE_COMMON_NFP: u32 = 1;
pub const RTE_COMMON_OCTEONTX: u32 = 1;
pub const RTE_COMMON_QAT: u32 = 1;
pub const RTE_COMMON_SFC_EFX: u32 = 1;
pub const RTE_COMPRESS_OCTEONTX: u32 = 1;
pub const RTE_CRYPTO_BCMFS: u32 = 1;
pub const RTE_CRYPTO_CAAM_JR: u32 = 1;
pub const RTE_CRYPTO_CCP: u32 = 1;
pub const RTE_CRYPTO_CNXK: u32 = 1;
pub const RTE_CRYPTO_DPAA2_SEC: u32 = 1;
pub const RTE_CRYPTO_DPAA_SEC: u32 = 1;
pub const RTE_CRYPTO_NITROX: u32 = 1;
pub const RTE_CRYPTO_NULL: u32 = 1;
pub const RTE_CRYPTO_OCTEONTX: u32 = 1;
pub const RTE_CRYPTO_OPENSSL: u32 = 1;
pub const RTE_CRYPTO_SCHEDULER: u32 = 1;
pub const RTE_CRYPTO_VIRTIO: u32 = 1;
pub const RTE_DMA_CNXK: u32 = 1;
pub const RTE_DMA_DPAA: u32 = 1;
pub const RTE_DMA_DPAA2: u32 = 1;
pub const RTE_DMA_HISILICON: u32 = 1;
pub const RTE_DMA_IDXD: u32 = 1;
pub const RTE_DMA_IOAT: u32 = 1;
pub const RTE_DMA_SKELETON: u32 = 1;
pub const RTE_DRIVER_MEMPOOL_BUCKET_SIZE_KB: u32 = 64;
pub const RTE_EAL_NUMA_AWARE_HUGEPAGES: u32 = 1;
pub const RTE_EAL_PMD_PATH: &[u8; 68] =
    b"/home/xyp/dpdk-sys/deps/install/lib/x86_64-linux-gnu/dpdk/pmds-24.0\0";
pub const RTE_ENV_FREEBSD: u32 = 0;
pub const RTE_ENV_LINUX: u32 = 1;
pub const RTE_ENV_WINDOWS: u32 = 2;
pub const RTE_EVENT_CNXK: u32 = 1;
pub const RTE_EVENT_DLB2: u32 = 1;
pub const RTE_EVENT_DPAA: u32 = 1;
pub const RTE_EVENT_DPAA2: u32 = 1;
pub const RTE_EVENT_DSW: u32 = 1;
pub const RTE_EVENT_OCTEONTX: u32 = 1;
pub const RTE_EVENT_OPDL: u32 = 1;
pub const RTE_EVENT_SKELETON: u32 = 1;
pub const RTE_EVENT_SW: u32 = 1;
pub const RTE_EXEC_ENV: u32 = 1;
pub const RTE_EXEC_ENV_IS_FREEBSD: u32 = 0;
pub const RTE_EXEC_ENV_IS_LINUX: u32 = 1;
pub const RTE_EXEC_ENV_IS_WINDOWS: u32 = 0;
pub const RTE_EXEC_ENV_LINUX: u32 = 1;
pub const RTE_HAS_LIBNUMA: u32 = 1;
pub const RTE_HAS_OPENSSL: u32 = 1;
pub const RTE_IOVA_IN_MBUF: u32 = 1;
pub const RTE_LIBRTE_VHOST_NUMA: u32 = 1;
pub const RTE_LIB_ACL: u32 = 1;
pub const RTE_LIB_BBDEV: u32 = 1;
pub const RTE_LIB_BITRATESTATS: u32 = 1;
pub const RTE_LIB_BPF: u32 = 1;
pub const RTE_LIB_CFGFILE: u32 = 1;
pub const RTE_LIB_CMDLINE: u32 = 1;
pub const RTE_LIB_COMPRESSDEV: u32 = 1;
pub const RTE_LIB_CRYPTODEV: u32 = 1;
pub const RTE_LIB_DISPATCHER: u32 = 1;
pub const RTE_LIB_DISTRIBUTOR: u32 = 1;
pub const RTE_LIB_DMADEV: u32 = 1;
pub const RTE_LIB_EAL: u32 = 1;
pub const RTE_LIB_EFD: u32 = 1;
pub const RTE_LIB_ETHDEV: u32 = 1;
pub const RTE_LIB_EVENTDEV: u32 = 1;
pub const RTE_LIB_FIB: u32 = 1;
pub const RTE_LIB_GPUDEV: u32 = 1;
pub const RTE_LIB_GRAPH: u32 = 1;
pub const RTE_LIB_GRO: u32 = 1;
pub const RTE_LIB_GSO: u32 = 1;
pub const RTE_LIB_HASH: u32 = 1;
pub const RTE_LIB_IPSEC: u32 = 1;
pub const RTE_LIB_IP_FRAG: u32 = 1;
pub const RTE_LIB_JOBSTATS: u32 = 1;
pub const RTE_LIB_KVARGS: u32 = 1;
pub const RTE_LIB_LATENCYSTATS: u32 = 1;
pub const RTE_LIB_LOG: u32 = 1;
pub const RTE_LIB_LPM: u32 = 1;
pub const RTE_LIB_MBUF: u32 = 1;
pub const RTE_LIB_MEMBER: u32 = 1;
pub const RTE_LIB_MEMPOOL: u32 = 1;
pub const RTE_LIB_METER: u32 = 1;
pub const RTE_LIB_METRICS: u32 = 1;
pub const RTE_LIB_MLDEV: u32 = 1;
pub const RTE_LIB_NET: u32 = 1;
pub const RTE_LIB_NODE: u32 = 1;
pub const RTE_LIB_PCAPNG: u32 = 1;
pub const RTE_LIB_PCI: u32 = 1;
pub const RTE_LIB_PDCP: u32 = 1;
pub const RTE_LIB_PDUMP: u32 = 1;
pub const RTE_LIB_PIPELINE: u32 = 1;
pub const RTE_LIB_PORT: u32 = 1;
pub const RTE_LIB_POWER: u32 = 1;
pub const RTE_LIB_RAWDEV: u32 = 1;
pub const RTE_LIB_RCU: u32 = 1;
pub const RTE_LIB_REGEXDEV: u32 = 1;
pub const RTE_LIB_REORDER: u32 = 1;
pub const RTE_LIB_RIB: u32 = 1;
pub const RTE_LIB_RING: u32 = 1;
pub const RTE_LIB_SCHED: u32 = 1;
pub const RTE_LIB_SECURITY: u32 = 1;
pub const RTE_LIB_STACK: u32 = 1;
pub const RTE_LIB_TABLE: u32 = 1;
pub const RTE_LIB_TELEMETRY: u32 = 1;
pub const RTE_LIB_TIMER: u32 = 1;
pub const RTE_LIB_VHOST: u32 = 1;
pub const RTE_MAX_ETHPORTS: u32 = 32;
pub const RTE_MAX_LCORE: u32 = 128;
pub const RTE_MAX_MEM_MB: u32 = 524288;
pub const RTE_MAX_NUMA_NODES: u32 = 32;
pub const RTE_MAX_VFIO_GROUPS: u32 = 64;
pub const RTE_MEMPOOL_BUCKET: u32 = 1;
pub const RTE_MEMPOOL_CNXK: u32 = 1;
pub const RTE_MEMPOOL_DPAA: u32 = 1;
pub const RTE_MEMPOOL_DPAA2: u32 = 1;
pub const RTE_MEMPOOL_OCTEONTX: u32 = 1;
pub const RTE_MEMPOOL_RING: u32 = 1;
pub const RTE_MEMPOOL_STACK: u32 = 1;
pub const RTE_ML_CNXK: u32 = 1;
pub const RTE_NET_AF_PACKET: u32 = 1;
pub const RTE_NET_ARK: u32 = 1;
pub const RTE_NET_ATLANTIC: u32 = 1;
pub const RTE_NET_AVP: u32 = 1;
pub const RTE_NET_AXGBE: u32 = 1;
pub const RTE_NET_BNXT: u32 = 1;
pub const RTE_NET_BOND: u32 = 1;
pub const RTE_NET_CNXK: u32 = 1;
pub const RTE_NET_CPFL: u32 = 1;
pub const RTE_NET_CXGBE: u32 = 1;
pub const RTE_NET_DPAA: u32 = 1;
pub const RTE_NET_DPAA2: u32 = 1;
pub const RTE_NET_E1000: u32 = 1;
pub const RTE_NET_ENA: u32 = 1;
pub const RTE_NET_ENETC: u32 = 1;
pub const RTE_NET_ENETFEC: u32 = 1;
pub const RTE_NET_ENIC: u32 = 1;
pub const RTE_NET_FAILSAFE: u32 = 1;
pub const RTE_NET_FM10K: u32 = 1;
pub const RTE_NET_GVE: u32 = 1;
pub const RTE_NET_HINIC: u32 = 1;
pub const RTE_NET_HNS3: u32 = 1;
pub const RTE_NET_I40E: u32 = 1;
pub const RTE_NET_IAVF: u32 = 1;
pub const RTE_NET_ICE: u32 = 1;
pub const RTE_NET_IDPF: u32 = 1;
pub const RTE_NET_IGC: u32 = 1;
pub const RTE_NET_IONIC: u32 = 1;
pub const RTE_NET_IXGBE: u32 = 1;
pub const RTE_NET_MEMIF: u32 = 1;
pub const RTE_NET_NETVSC: u32 = 1;
pub const RTE_NET_NFP: u32 = 1;
pub const RTE_NET_NGBE: u32 = 1;
pub const RTE_NET_NULL: u32 = 1;
pub const RTE_NET_OCTEONTX: u32 = 1;
pub const RTE_NET_OCTEON_EP: u32 = 1;
pub const RTE_NET_PFE: u32 = 1;
pub const RTE_NET_QEDE: u32 = 1;
pub const RTE_NET_RING: u32 = 1;
pub const RTE_NET_SFC: u32 = 1;
pub const RTE_NET_SOFTNIC: u32 = 1;
pub const RTE_NET_TAP: u32 = 1;
pub const RTE_NET_THUNDERX: u32 = 1;
pub const RTE_NET_TXGBE: u32 = 1;
pub const RTE_NET_VDEV_NETVSC: u32 = 1;
pub const RTE_NET_VHOST: u32 = 1;
pub const RTE_NET_VIRTIO: u32 = 1;
pub const RTE_NET_VMXNET3: u32 = 1;
pub const RTE_RAW_CNXK_BPHY: u32 = 1;
pub const RTE_RAW_CNXK_GPIO: u32 = 1;
pub const RTE_RAW_DPAA2_CMDIF: u32 = 1;
pub const RTE_RAW_NTB: u32 = 1;
pub const RTE_RAW_SKELETON: u32 = 1;
pub const RTE_REGEX_CN9K: u32 = 1;
pub const RTE_TOOLCHAIN: &[u8; 4] = b"gcc\0";
pub const RTE_TOOLCHAIN_GCC: u32 = 1;
pub const RTE_VDPA_IFC: u32 = 1;
pub const RTE_VDPA_NFP: u32 = 1;
pub const RTE_VDPA_SFC: u32 = 1;
pub const RTE_VER_MINOR: u32 = 1;
pub const RTE_VER_MONTH: u32 = 11;
pub const RTE_VER_RELEASE: u32 = 99;
pub const RTE_VER_SUFFIX: &[u8; 1] = b"\0";
pub const RTE_VER_YEAR: u32 = 23;
pub const RTE_EXEC_ENV_LINUXAPP: u32 = 1;
pub const RTE_VER_PREFIX: &[u8; 5] = b"DPDK\0";
pub const RTE_CACHE_GUARD_LINES: u32 = 1;
pub const RTE_MAX_HEAPS: u32 = 32;
pub const RTE_MAX_MEMSEG_LISTS: u32 = 128;
pub const RTE_MAX_MEMSEG_PER_LIST: u32 = 8192;
pub const RTE_MAX_MEM_MB_PER_LIST: u32 = 32768;
pub const RTE_MAX_MEMSEG_PER_TYPE: u32 = 32768;
pub const RTE_MAX_MEM_MB_PER_TYPE: u32 = 65536;
pub const RTE_MAX_TAILQ: u32 = 32;
pub const RTE_MAX_VFIO_CONTAINERS: u32 = 64;
pub const RTE_CONTIGMEM_MAX_NUM_BUFS: u32 = 64;
pub const RTE_CONTIGMEM_DEFAULT_NUM_BUFS: u32 = 1;
pub const RTE_CONTIGMEM_DEFAULT_BUF_SIZE: u32 = 536870912;
pub const RTE_MEMPOOL_CACHE_MAX_SIZE: u32 = 512;
pub const RTE_MBUF_DEFAULT_MEMPOOL_OPS: &[u8; 11] = b"ring_mp_mc\0";
pub const RTE_PKTMBUF_HEADROOM: u32 = 128;
pub const RTE_MAX_QUEUES_PER_PORT: u32 = 1024;
pub const RTE_ETHDEV_QUEUE_STAT_CNTRS: u32 = 16;
pub const RTE_ETHDEV_RXTX_CALLBACKS: u32 = 1;
pub const RTE_MAX_MULTI_HOST_CTRLS: u32 = 4;
pub const RTE_CRYPTO_MAX_DEVS: u32 = 64;
pub const RTE_CRYPTODEV_NAME_LEN: u32 = 64;
pub const RTE_CRYPTO_CALLBACKS: u32 = 1;
pub const RTE_COMPRESS_MAX_DEVS: u32 = 64;
pub const RTE_MAX_REGEXDEV_DEVS: u32 = 32;
pub const RTE_EVENT_MAX_DEVS: u32 = 16;
pub const RTE_EVENT_MAX_PORTS_PER_DEV: u32 = 255;
pub const RTE_EVENT_MAX_QUEUES_PER_DEV: u32 = 255;
pub const RTE_EVENT_MAX_PROFILES_PER_PORT: u32 = 8;
pub const RTE_EVENT_TIMER_ADAPTER_NUM_MAX: u32 = 32;
pub const RTE_EVENT_ETH_INTR_RING_SIZE: u32 = 1024;
pub const RTE_EVENT_CRYPTO_ADAPTER_MAX_INSTANCE: u32 = 32;
pub const RTE_EVENT_ETH_TX_ADAPTER_MAX_INSTANCE: u32 = 32;
pub const RTE_EVENT_DMA_ADAPTER_MAX_INSTANCE: u32 = 32;
pub const RTE_RAWDEV_MAX_DEVS: u32 = 64;
pub const RTE_LIBRTE_IP_FRAG_MAX_FRAG: u32 = 8;
pub const RTE_MAX_LCORE_FREQS: u32 = 64;
pub const RTE_MAX_UNCORE_FREQS: u32 = 64;
pub const RTE_GRAPH_BURST_SIZE: u32 = 256;
pub const RTE_LIBRTE_GRAPH_STATS: u32 = 1;
pub const RTE_PMD_PACKET_PREFETCH: u32 = 1;
pub const RTE_PMD_QAT_MAX_PCI_DEVICES: u32 = 48;
pub const RTE_PMD_QAT_COMP_SGL_MAX_SEGMENTS: u32 = 16;
pub const RTE_PMD_QAT_COMP_IM_BUFFER_SIZE: u32 = 65536;
pub const RTE_MAX_VIRTIO_CRYPTO: u32 = 32;
pub const RTE_LIBRTE_DPAA_MAX_CRYPTODEV: u32 = 4;
pub const RTE_LIBRTE_FM10K_RX_OLFLAGS_ENABLE: u32 = 1;
pub const RTE_LIBRTE_HNS3_MAX_TQP_NUM_PER_PF: u32 = 256;
pub const RTE_LIBRTE_I40E_RX_ALLOW_BULK_ALLOC: u32 = 1;
pub const RTE_LIBRTE_I40E_QUEUE_NUM_PER_PF: u32 = 64;
pub const RTE_LIBRTE_I40E_QUEUE_NUM_PER_VF: u32 = 4;
pub const RTE_LIBRTE_I40E_QUEUE_NUM_PER_VM: u32 = 4;
pub const RTE_PMD_RING_MAX_RX_RINGS: u32 = 16;
pub const RTE_PMD_RING_MAX_TX_RINGS: u32 = 16;
pub const RTE_LIBRTE_QEDE_FW: &[u8; 1] = b"\0";
pub const RTE_UUID_STRLEN: u32 = 37;
pub const RTE_MAGIC: u32 = 19820526;
pub const RTE_MP_MAX_FD_NUM: u32 = 8;
pub const RTE_MP_MAX_NAME_LEN: u32 = 64;
pub const RTE_MP_MAX_PARAM_LEN: u32 = 256;
pub const RTE_CC_IS_GNU: u32 = 0;
pub const RTE_PRIORITY_LOG: u32 = 101;
pub const RTE_PRIORITY_BUS: u32 = 110;
pub const RTE_PRIORITY_CLASS: u32 = 120;
pub const RTE_PRIORITY_LAST: u32 = 65535;
pub const RTE_CACHE_LINE_MASK: u32 = 63;
pub const RTE_CACHE_LINE_SIZE_LOG2: u32 = 6;
pub const RTE_CACHE_LINE_MIN_SIZE: u32 = 64;
pub const RTE_LOGTYPE_EAL: u32 = 0;
pub const RTE_LOGTYPE_MALLOC: u32 = 1;
pub const RTE_LOGTYPE_RING: u32 = 2;
pub const RTE_LOGTYPE_MEMPOOL: u32 = 3;
pub const RTE_LOGTYPE_TIMER: u32 = 4;
pub const RTE_LOGTYPE_PMD: u32 = 5;
pub const RTE_LOGTYPE_HASH: u32 = 6;
pub const RTE_LOGTYPE_LPM: u32 = 7;
pub const RTE_LOGTYPE_ACL: u32 = 9;
pub const RTE_LOGTYPE_POWER: u32 = 10;
pub const RTE_LOGTYPE_METER: u32 = 11;
pub const RTE_LOGTYPE_SCHED: u32 = 12;
pub const RTE_LOGTYPE_PORT: u32 = 13;
pub const RTE_LOGTYPE_TABLE: u32 = 14;
pub const RTE_LOGTYPE_PIPELINE: u32 = 15;
pub const RTE_LOGTYPE_MBUF: u32 = 16;
pub const RTE_LOGTYPE_CRYPTODEV: u32 = 17;
pub const RTE_LOGTYPE_EFD: u32 = 18;
pub const RTE_LOGTYPE_EVENTDEV: u32 = 19;
pub const RTE_LOGTYPE_GSO: u32 = 20;
pub const RTE_LOGTYPE_USER1: u32 = 24;
pub const RTE_LOGTYPE_USER2: u32 = 25;
pub const RTE_LOGTYPE_USER3: u32 = 26;
pub const RTE_LOGTYPE_USER4: u32 = 27;
pub const RTE_LOGTYPE_USER5: u32 = 28;
pub const RTE_LOGTYPE_USER6: u32 = 29;
pub const RTE_LOGTYPE_USER7: u32 = 30;
pub const RTE_LOGTYPE_USER8: u32 = 31;
pub const RTE_LOGTYPE_FIRST_EXT_ID: u32 = 32;
pub const RTE_LOG_EMERG: u32 = 1;
pub const RTE_LOG_ALERT: u32 = 2;
pub const RTE_LOG_CRIT: u32 = 3;
pub const RTE_LOG_ERR: u32 = 4;
pub const RTE_LOG_WARNING: u32 = 5;
pub const RTE_LOG_NOTICE: u32 = 6;
pub const RTE_LOG_INFO: u32 = 7;
pub const RTE_LOG_DEBUG: u32 = 8;
pub const RTE_LOG_MAX: u32 = 8;
pub const RTE_INTR_EVENT_ADD: u32 = 1;
pub const RTE_INTR_EVENT_DEL: u32 = 2;
pub const RTE_EPOLL_PER_THREAD: i32 = -1;
pub const RTE_MAX_RXTX_INTR_VEC_ID: u32 = 512;
pub const RTE_INTR_VEC_ZERO_OFFSET: u32 = 0;
pub const RTE_INTR_VEC_RXTX_OFFSET: u32 = 1;
pub const RTE_DEV_NAME_MAX_LEN: u32 = 64;
pub const RTE_DEVARGS_KEY_BUS: &[u8; 4] = b"bus\0";
pub const RTE_DEVARGS_KEY_CLASS: &[u8; 6] = b"class\0";
pub const RTE_DEVARGS_KEY_DRIVER: &[u8; 7] = b"driver\0";
pub const RTE_THREAD_NAME_SIZE: u32 = 16;
pub const RTE_MAX_THREAD_NAME_LEN: u32 = 16;
pub const RTE_THREAD_INTERNAL_PREFIX: &[u8; 6] = b"dpdk-\0";
pub const RTE_THREAD_INTERNAL_NAME_SIZE: u32 = 11;
pub const RTE_XBEGIN_STARTED: i32 = -1;
pub const RTE_XABORT_EXPLICIT: u32 = 1;
pub const RTE_XABORT_RETRY: u32 = 2;
pub const RTE_XABORT_CONFLICT: u32 = 4;
pub const RTE_XABORT_CAPACITY: u32 = 8;
pub const RTE_XABORT_DEBUG: u32 = 16;
pub const RTE_XABORT_NESTED: u32 = 32;
pub const RTE_RTM_MAX_RETRIES: u32 = 20;
pub const RTE_XABORT_LOCK_BUSY: u32 = 255;
pub const RTE_POWER_MONITOR_OPAQUE_SZ: u32 = 4;
pub const RTE_TRACE_BLOB_LEN_MAX: u32 = 64;
pub const RTE_ETH_MODULE_SFF_8079: u32 = 1;
pub const RTE_ETH_MODULE_SFF_8079_LEN: u32 = 256;
pub const RTE_ETH_MODULE_SFF_8472: u32 = 2;
pub const RTE_ETH_MODULE_SFF_8472_LEN: u32 = 512;
pub const RTE_ETH_MODULE_SFF_8636: u32 = 3;
pub const RTE_ETH_MODULE_SFF_8636_LEN: u32 = 256;
pub const RTE_ETH_MODULE_SFF_8636_MAX_LEN: u32 = 640;
pub const RTE_ETH_MODULE_SFF_8436: u32 = 4;
pub const RTE_ETH_MODULE_SFF_8436_LEN: u32 = 256;
pub const RTE_ETH_MODULE_SFF_8436_MAX_LEN: u32 = 640;
pub const RTE_ETH_LINK_SPEED_AUTONEG: u32 = 0;
pub const RTE_ETH_SPEED_NUM_NONE: u32 = 0;
pub const RTE_ETH_SPEED_NUM_10M: u32 = 10;
pub const RTE_ETH_SPEED_NUM_100M: u32 = 100;
pub const RTE_ETH_SPEED_NUM_1G: u32 = 1000;
pub const RTE_ETH_SPEED_NUM_2_5G: u32 = 2500;
pub const RTE_ETH_SPEED_NUM_5G: u32 = 5000;
pub const RTE_ETH_SPEED_NUM_10G: u32 = 10000;
pub const RTE_ETH_SPEED_NUM_20G: u32 = 20000;
pub const RTE_ETH_SPEED_NUM_25G: u32 = 25000;
pub const RTE_ETH_SPEED_NUM_40G: u32 = 40000;
pub const RTE_ETH_SPEED_NUM_50G: u32 = 50000;
pub const RTE_ETH_SPEED_NUM_56G: u32 = 56000;
pub const RTE_ETH_SPEED_NUM_100G: u32 = 100000;
pub const RTE_ETH_SPEED_NUM_200G: u32 = 200000;
pub const RTE_ETH_SPEED_NUM_400G: u32 = 400000;
pub const RTE_ETH_SPEED_NUM_UNKNOWN: u32 = 4294967295;
pub const RTE_ETH_LINK_HALF_DUPLEX: u32 = 0;
pub const RTE_ETH_LINK_FULL_DUPLEX: u32 = 1;
pub const RTE_ETH_LINK_DOWN: u32 = 0;
pub const RTE_ETH_LINK_UP: u32 = 1;
pub const RTE_ETH_LINK_FIXED: u32 = 0;
pub const RTE_ETH_LINK_AUTONEG: u32 = 1;
pub const RTE_ETH_LINK_MAX_STR_LEN: u32 = 40;
pub const RTE_ETH_FLOW_UNKNOWN: u32 = 0;
pub const RTE_ETH_FLOW_RAW: u32 = 1;
pub const RTE_ETH_FLOW_IPV4: u32 = 2;
pub const RTE_ETH_FLOW_FRAG_IPV4: u32 = 3;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_TCP: u32 = 4;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_UDP: u32 = 5;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_SCTP: u32 = 6;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_OTHER: u32 = 7;
pub const RTE_ETH_FLOW_IPV6: u32 = 8;
pub const RTE_ETH_FLOW_FRAG_IPV6: u32 = 9;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_TCP: u32 = 10;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_UDP: u32 = 11;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_SCTP: u32 = 12;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_OTHER: u32 = 13;
pub const RTE_ETH_FLOW_L2_PAYLOAD: u32 = 14;
pub const RTE_ETH_FLOW_IPV6_EX: u32 = 15;
pub const RTE_ETH_FLOW_IPV6_TCP_EX: u32 = 16;
pub const RTE_ETH_FLOW_IPV6_UDP_EX: u32 = 17;
pub const RTE_ETH_FLOW_PORT: u32 = 18;
pub const RTE_ETH_FLOW_VXLAN: u32 = 19;
pub const RTE_ETH_FLOW_GENEVE: u32 = 20;
pub const RTE_ETH_FLOW_NVGRE: u32 = 21;
pub const RTE_ETH_FLOW_VXLAN_GPE: u32 = 22;
pub const RTE_ETH_FLOW_GTPU: u32 = 23;
pub const RTE_ETH_FLOW_MAX: u32 = 24;
pub const RTE_ETH_RSS_RETA_SIZE_64: u32 = 64;
pub const RTE_ETH_RSS_RETA_SIZE_128: u32 = 128;
pub const RTE_ETH_RSS_RETA_SIZE_256: u32 = 256;
pub const RTE_ETH_RSS_RETA_SIZE_512: u32 = 512;
pub const RTE_ETH_RETA_GROUP_SIZE: u32 = 64;
pub const RTE_ETH_VMDQ_MAX_VLAN_FILTERS: u32 = 64;
pub const RTE_ETH_DCB_NUM_USER_PRIORITIES: u32 = 8;
pub const RTE_ETH_VMDQ_DCB_NUM_QUEUES: u32 = 128;
pub const RTE_ETH_DCB_NUM_QUEUES: u32 = 128;
pub const RTE_ETH_VLAN_STRIP_OFFLOAD: u32 = 1;
pub const RTE_ETH_VLAN_FILTER_OFFLOAD: u32 = 2;
pub const RTE_ETH_VLAN_EXTEND_OFFLOAD: u32 = 4;
pub const RTE_ETH_QINQ_STRIP_OFFLOAD: u32 = 8;
pub const RTE_ETH_VLAN_STRIP_MASK: u32 = 1;
pub const RTE_ETH_VLAN_FILTER_MASK: u32 = 2;
pub const RTE_ETH_VLAN_EXTEND_MASK: u32 = 4;
pub const RTE_ETH_QINQ_STRIP_MASK: u32 = 8;
pub const RTE_ETH_VLAN_ID_MAX: u32 = 4095;
pub const RTE_ETH_NUM_RECEIVE_MAC_ADDR: u32 = 128;
pub const RTE_ETH_VMDQ_NUM_UC_HASH_ARRAY: u32 = 128;
pub const RTE_ETH_MAX_HAIRPIN_PEERS: u32 = 32;
pub const RTE_RWLOCK_WAIT: u32 = 1;
pub const RTE_RWLOCK_WRITE: u32 = 2;
pub const RTE_RWLOCK_MASK: u32 = 3;
pub const RTE_RWLOCK_READ: u32 = 4;
pub const RTE_FBARRAY_NAME_LEN: u32 = 64;
pub const RTE_PGSIZE_4K: u32 = 4096;
pub const RTE_PGSIZE_64K: u32 = 65536;
pub const RTE_PGSIZE_256K: u32 = 262144;
pub const RTE_PGSIZE_2M: u32 = 2097152;
pub const RTE_PGSIZE_16M: u32 = 16777216;
pub const RTE_PGSIZE_256M: u32 = 268435456;
pub const RTE_PGSIZE_512M: u32 = 536870912;
pub const RTE_PGSIZE_1G: u32 = 1073741824;
pub const RTE_PGSIZE_4G: u64 = 4294967296;
pub const RTE_PGSIZE_16G: u64 = 17179869184;
pub const RTE_MEM_EVENT_CALLBACK_NAME_LEN: u32 = 64;
pub const RTE_MEM_ALLOC_VALIDATOR_NAME_LEN: u32 = 64;
pub const RTE_MEMZONE_2MB: u32 = 1;
pub const RTE_MEMZONE_1GB: u32 = 2;
pub const RTE_MEMZONE_16MB: u32 = 256;
pub const RTE_MEMZONE_16GB: u32 = 512;
pub const RTE_MEMZONE_256KB: u32 = 65536;
pub const RTE_MEMZONE_256MB: u32 = 131072;
pub const RTE_MEMZONE_512MB: u32 = 262144;
pub const RTE_MEMZONE_4GB: u32 = 524288;
pub const RTE_MEMZONE_SIZE_HINT_ONLY: u32 = 4;
pub const RTE_MEMZONE_IOVA_CONTIG: u32 = 1048576;
pub const RTE_MEMZONE_NAMESIZE: u32 = 32;
pub const RTE_TAILQ_RING_NAME: &[u8; 9] = b"RTE_RING\0";
pub const RTE_RING_MZ_PREFIX: &[u8; 4] = b"RG_\0";
pub const RTE_RING_SZ_MASK: u32 = 2147483647;
pub const RTE_MEMPOOL_HEADER_COOKIE1: i64 = -4982197544707871147;
pub const RTE_MEMPOOL_HEADER_COOKIE2: i64 = -941548164385788331;
pub const RTE_MEMPOOL_TRAILER_COOKIE: i64 = -5921418378119291987;
pub const RTE_MEMPOOL_MZ_PREFIX: &[u8; 4] = b"MP_\0";
pub const RTE_MEMPOOL_MZ_FORMAT: &[u8; 6] = b"MP_%s\0";
pub const RTE_MEMPOOL_ALIGN: u32 = 64;
pub const RTE_MEMPOOL_ALIGN_MASK: u32 = 63;
pub const RTE_MEMPOOL_F_NO_SPREAD: u32 = 1;
pub const RTE_MEMPOOL_F_NO_CACHE_ALIGN: u32 = 2;
pub const RTE_MEMPOOL_F_SP_PUT: u32 = 4;
pub const RTE_MEMPOOL_F_SC_GET: u32 = 8;
pub const RTE_MEMPOOL_F_POOL_CREATED: u32 = 16;
pub const RTE_MEMPOOL_F_NO_IOVA_CONTIG: u32 = 32;
pub const RTE_MEMPOOL_F_NON_IO: u32 = 64;
pub const RTE_MEMPOOL_VALID_USER_FLAGS: u32 = 47;
pub const RTE_MEMPOOL_OPS_NAMESIZE: u32 = 32;
pub const RTE_MEMPOOL_POPULATE_F_ALIGN_OBJ: u32 = 1;
pub const RTE_MEMPOOL_MAX_OPS_IDX: u32 = 16;
pub const RTE_PTYPE_UNKNOWN: u32 = 0;
pub const RTE_PTYPE_L2_ETHER: u32 = 1;
pub const RTE_PTYPE_L2_ETHER_TIMESYNC: u32 = 2;
pub const RTE_PTYPE_L2_ETHER_ARP: u32 = 3;
pub const RTE_PTYPE_L2_ETHER_LLDP: u32 = 4;
pub const RTE_PTYPE_L2_ETHER_NSH: u32 = 5;
pub const RTE_PTYPE_L2_ETHER_VLAN: u32 = 6;
pub const RTE_PTYPE_L2_ETHER_QINQ: u32 = 7;
pub const RTE_PTYPE_L2_ETHER_PPPOE: u32 = 8;
pub const RTE_PTYPE_L2_ETHER_FCOE: u32 = 9;
pub const RTE_PTYPE_L2_ETHER_MPLS: u32 = 10;
pub const RTE_PTYPE_L2_MASK: u32 = 15;
pub const RTE_PTYPE_L3_IPV4: u32 = 16;
pub const RTE_PTYPE_L3_IPV4_EXT: u32 = 48;
pub const RTE_PTYPE_L3_IPV6: u32 = 64;
pub const RTE_PTYPE_L3_IPV4_EXT_UNKNOWN: u32 = 144;
pub const RTE_PTYPE_L3_IPV6_EXT: u32 = 192;
pub const RTE_PTYPE_L3_IPV6_EXT_UNKNOWN: u32 = 224;
pub const RTE_PTYPE_L3_MASK: u32 = 240;
pub const RTE_PTYPE_L4_TCP: u32 = 256;
pub const RTE_PTYPE_L4_UDP: u32 = 512;
pub const RTE_PTYPE_L4_FRAG: u32 = 768;
pub const RTE_PTYPE_L4_SCTP: u32 = 1024;
pub const RTE_PTYPE_L4_ICMP: u32 = 1280;
pub const RTE_PTYPE_L4_NONFRAG: u32 = 1536;
pub const RTE_PTYPE_L4_IGMP: u32 = 1792;
pub const RTE_PTYPE_L4_MASK: u32 = 3840;
pub const RTE_PTYPE_TUNNEL_IP: u32 = 4096;
pub const RTE_PTYPE_TUNNEL_GRE: u32 = 8192;
pub const RTE_PTYPE_TUNNEL_VXLAN: u32 = 12288;
pub const RTE_PTYPE_TUNNEL_NVGRE: u32 = 16384;
pub const RTE_PTYPE_TUNNEL_GENEVE: u32 = 20480;
pub const RTE_PTYPE_TUNNEL_GRENAT: u32 = 24576;
pub const RTE_PTYPE_TUNNEL_GTPC: u32 = 28672;
pub const RTE_PTYPE_TUNNEL_GTPU: u32 = 32768;
pub const RTE_PTYPE_TUNNEL_ESP: u32 = 36864;
pub const RTE_PTYPE_TUNNEL_L2TP: u32 = 40960;
pub const RTE_PTYPE_TUNNEL_VXLAN_GPE: u32 = 45056;
pub const RTE_PTYPE_TUNNEL_MPLS_IN_GRE: u32 = 49152;
pub const RTE_PTYPE_TUNNEL_MPLS_IN_UDP: u32 = 53248;
pub const RTE_PTYPE_TUNNEL_MASK: u32 = 61440;
pub const RTE_PTYPE_INNER_L2_ETHER: u32 = 65536;
pub const RTE_PTYPE_INNER_L2_ETHER_VLAN: u32 = 131072;
pub const RTE_PTYPE_INNER_L2_ETHER_QINQ: u32 = 196608;
pub const RTE_PTYPE_INNER_L2_MASK: u32 = 983040;
pub const RTE_PTYPE_INNER_L3_IPV4: u32 = 1048576;
pub const RTE_PTYPE_INNER_L3_IPV4_EXT: u32 = 2097152;
pub const RTE_PTYPE_INNER_L3_IPV6: u32 = 3145728;
pub const RTE_PTYPE_INNER_L3_IPV4_EXT_UNKNOWN: u32 = 4194304;
pub const RTE_PTYPE_INNER_L3_IPV6_EXT: u32 = 5242880;
pub const RTE_PTYPE_INNER_L3_IPV6_EXT_UNKNOWN: u32 = 6291456;
pub const RTE_PTYPE_INNER_L3_MASK: u32 = 15728640;
pub const RTE_PTYPE_INNER_L4_TCP: u32 = 16777216;
pub const RTE_PTYPE_INNER_L4_UDP: u32 = 33554432;
pub const RTE_PTYPE_INNER_L4_FRAG: u32 = 50331648;
pub const RTE_PTYPE_INNER_L4_SCTP: u32 = 67108864;
pub const RTE_PTYPE_INNER_L4_ICMP: u32 = 83886080;
pub const RTE_PTYPE_INNER_L4_NONFRAG: u32 = 100663296;
pub const RTE_PTYPE_INNER_L4_MASK: u32 = 251658240;
pub const RTE_PTYPE_ALL_MASK: u32 = 268435455;
pub const RTE_BIG_ENDIAN: u32 = 1;
pub const RTE_LITTLE_ENDIAN: u32 = 2;
pub const RTE_BYTE_ORDER: u32 = 2;
pub const RTE_MBUF_F_RX_VLAN: u32 = 1;
pub const RTE_MBUF_F_RX_RSS_HASH: u32 = 2;
pub const RTE_MBUF_F_RX_FDIR: u32 = 4;
pub const RTE_MBUF_F_RX_OUTER_IP_CKSUM_BAD: u32 = 32;
pub const RTE_MBUF_F_RX_VLAN_STRIPPED: u32 = 64;
pub const RTE_MBUF_F_RX_IP_CKSUM_MASK: u32 = 144;
pub const RTE_MBUF_F_RX_IP_CKSUM_UNKNOWN: u32 = 0;
pub const RTE_MBUF_F_RX_IP_CKSUM_BAD: u32 = 16;
pub const RTE_MBUF_F_RX_IP_CKSUM_GOOD: u32 = 128;
pub const RTE_MBUF_F_RX_IP_CKSUM_NONE: u32 = 144;
pub const RTE_MBUF_F_RX_L4_CKSUM_MASK: u32 = 264;
pub const RTE_MBUF_F_RX_L4_CKSUM_UNKNOWN: u32 = 0;
pub const RTE_MBUF_F_RX_L4_CKSUM_BAD: u32 = 8;
pub const RTE_MBUF_F_RX_L4_CKSUM_GOOD: u32 = 256;
pub const RTE_MBUF_F_RX_L4_CKSUM_NONE: u32 = 264;
pub const RTE_MBUF_F_RX_IEEE1588_PTP: u32 = 512;
pub const RTE_MBUF_F_RX_IEEE1588_TMST: u32 = 1024;
pub const RTE_MBUF_F_RX_FDIR_ID: u32 = 8192;
pub const RTE_MBUF_F_RX_FDIR_FLX: u32 = 16384;
pub const RTE_MBUF_F_RX_QINQ_STRIPPED: u32 = 32768;
pub const RTE_MBUF_F_RX_LRO: u32 = 65536;
pub const RTE_MBUF_F_RX_SEC_OFFLOAD: u32 = 262144;
pub const RTE_MBUF_F_RX_SEC_OFFLOAD_FAILED: u32 = 524288;
pub const RTE_MBUF_F_RX_QINQ: u32 = 1048576;
pub const RTE_MBUF_F_RX_OUTER_L4_CKSUM_MASK: u32 = 6291456;
pub const RTE_MBUF_F_RX_OUTER_L4_CKSUM_UNKNOWN: u32 = 0;
pub const RTE_MBUF_F_RX_OUTER_L4_CKSUM_BAD: u32 = 2097152;
pub const RTE_MBUF_F_RX_OUTER_L4_CKSUM_GOOD: u32 = 4194304;
pub const RTE_MBUF_F_RX_OUTER_L4_CKSUM_INVALID: u32 = 6291456;
pub const RTE_MBUF_F_FIRST_FREE: u32 = 8388608;
pub const RTE_MBUF_F_LAST_FREE: u64 = 1099511627776;
pub const RTE_MBUF_F_TX_OUTER_UDP_CKSUM: u64 = 2199023255552;
pub const RTE_MBUF_F_TX_UDP_SEG: u64 = 4398046511104;
pub const RTE_MBUF_F_TX_SEC_OFFLOAD: u64 = 8796093022208;
pub const RTE_MBUF_F_TX_MACSEC: u64 = 17592186044416;
pub const RTE_MBUF_F_TX_TUNNEL_VXLAN: u64 = 35184372088832;
pub const RTE_MBUF_F_TX_TUNNEL_GRE: u64 = 70368744177664;
pub const RTE_MBUF_F_TX_TUNNEL_IPIP: u64 = 105553116266496;
pub const RTE_MBUF_F_TX_TUNNEL_GENEVE: u64 = 140737488355328;
pub const RTE_MBUF_F_TX_TUNNEL_MPLSINUDP: u64 = 175921860444160;
pub const RTE_MBUF_F_TX_TUNNEL_VXLAN_GPE: u64 = 211106232532992;
pub const RTE_MBUF_F_TX_TUNNEL_GTP: u64 = 246290604621824;
pub const RTE_MBUF_F_TX_TUNNEL_ESP: u64 = 281474976710656;
pub const RTE_MBUF_F_TX_TUNNEL_IP: u64 = 457396837154816;
pub const RTE_MBUF_F_TX_TUNNEL_UDP: u64 = 492581209243648;
pub const RTE_MBUF_F_TX_TUNNEL_MASK: u64 = 527765581332480;
pub const RTE_MBUF_F_TX_QINQ: u64 = 562949953421312;
pub const RTE_MBUF_F_TX_TCP_SEG: u64 = 1125899906842624;
pub const RTE_MBUF_F_TX_IEEE1588_TMST: u64 = 2251799813685248;
pub const RTE_MBUF_F_TX_L4_NO_CKSUM: u32 = 0;
pub const RTE_MBUF_F_TX_TCP_CKSUM: u64 = 4503599627370496;
pub const RTE_MBUF_F_TX_SCTP_CKSUM: u64 = 9007199254740992;
pub const RTE_MBUF_F_TX_UDP_CKSUM: u64 = 13510798882111488;
pub const RTE_MBUF_F_TX_L4_MASK: u64 = 13510798882111488;
pub const RTE_MBUF_F_TX_IP_CKSUM: u64 = 18014398509481984;
pub const RTE_MBUF_F_TX_IPV4: u64 = 36028797018963968;
pub const RTE_MBUF_F_TX_IPV6: u64 = 72057594037927936;
pub const RTE_MBUF_F_TX_VLAN: u64 = 144115188075855872;
pub const RTE_MBUF_F_TX_OUTER_IP_CKSUM: u64 = 288230376151711744;
pub const RTE_MBUF_F_TX_OUTER_IPV4: u64 = 576460752303423488;
pub const RTE_MBUF_F_TX_OUTER_IPV6: u64 = 1152921504606846976;
pub const RTE_MBUF_F_TX_OFFLOAD_MASK: u64 = 2305840810190438400;
pub const RTE_MBUF_F_EXTERNAL: u64 = 2305843009213693952;
pub const RTE_MBUF_F_INDIRECT: u64 = 4611686018427387904;
pub const RTE_MBUF_PRIV_ALIGN: u32 = 8;
pub const RTE_MBUF_DEFAULT_DATAROOM: u32 = 2048;
pub const RTE_MBUF_DEFAULT_BUF_SIZE: u32 = 2176;
pub const RTE_MBUF_MAX_NB_SEGS: u32 = 65535;
pub const RTE_MBUF_PORT_INVALID: u32 = 65535;
pub const RTE_PKTMBUF_POOL_F_PINNED_EXT_BUF: u32 = 1;
pub const RTE_ETHER_ADDR_LEN: u32 = 6;
pub const RTE_ETHER_TYPE_LEN: u32 = 2;
pub const RTE_ETHER_CRC_LEN: u32 = 4;
pub const RTE_ETHER_HDR_LEN: u32 = 14;
pub const RTE_ETHER_MIN_LEN: u32 = 64;
pub const RTE_ETHER_MAX_LEN: u32 = 1518;
pub const RTE_ETHER_MTU: u32 = 1500;
pub const RTE_VLAN_HLEN: u32 = 4;
pub const RTE_ETHER_MAX_VLAN_FRAME_LEN: u32 = 1522;
pub const RTE_ETHER_MAX_JUMBO_FRAME_LEN: u32 = 16128;
pub const RTE_ETHER_MAX_VLAN_ID: u32 = 4095;
pub const RTE_ETHER_MIN_MTU: u32 = 68;
pub const RTE_VLAN_DEI_SHIFT: u32 = 12;
pub const RTE_VLAN_PRI_SHIFT: u32 = 13;
pub const RTE_VLAN_PRI_MASK: u32 = 57344;
pub const RTE_VLAN_DEI_MASK: u32 = 4096;
pub const RTE_VLAN_ID_MASK: u32 = 4095;
pub const RTE_ETHER_LOCAL_ADMIN_ADDR: u32 = 2;
pub const RTE_ETHER_GROUP_ADDR: u32 = 1;
pub const RTE_ETHER_ADDR_PRT_FMT: &[u8; 30] = b"%02X:%02X:%02X:%02X:%02X:%02X\0";
pub const RTE_ETHER_ADDR_FMT_SIZE: u32 = 18;
pub const RTE_ETHER_TYPE_IPV4: u32 = 2048;
pub const RTE_ETHER_TYPE_IPV6: u32 = 34525;
pub const RTE_ETHER_TYPE_ARP: u32 = 2054;
pub const RTE_ETHER_TYPE_RARP: u32 = 32821;
pub const RTE_ETHER_TYPE_VLAN: u32 = 33024;
pub const RTE_ETHER_TYPE_QINQ: u32 = 34984;
pub const RTE_ETHER_TYPE_QINQ1: u32 = 37120;
pub const RTE_ETHER_TYPE_QINQ2: u32 = 37376;
pub const RTE_ETHER_TYPE_QINQ3: u32 = 37632;
pub const RTE_ETHER_TYPE_PPPOE_DISCOVERY: u32 = 34915;
pub const RTE_ETHER_TYPE_PPPOE_SESSION: u32 = 34916;
pub const RTE_ETHER_TYPE_ETAG: u32 = 35135;
pub const RTE_ETHER_TYPE_1588: u32 = 35063;
pub const RTE_ETHER_TYPE_SLOW: u32 = 34825;
pub const RTE_ETHER_TYPE_TEB: u32 = 25944;
pub const RTE_ETHER_TYPE_LLDP: u32 = 35020;
pub const RTE_ETHER_TYPE_MPLS: u32 = 34887;
pub const RTE_ETHER_TYPE_MPLSM: u32 = 34888;
pub const RTE_ETHER_TYPE_ECPRI: u32 = 44798;
pub const RTE_ARP_HRD_ETHER: u32 = 1;
pub const RTE_ARP_OP_REQUEST: u32 = 1;
pub const RTE_ARP_OP_REPLY: u32 = 2;
pub const RTE_ARP_OP_REVREQUEST: u32 = 3;
pub const RTE_ARP_OP_REVREPLY: u32 = 4;
pub const RTE_ARP_OP_INVREQUEST: u32 = 8;
pub const RTE_ARP_OP_INVREPLY: u32 = 9;
pub const RTE_IP_ICMP_ECHO_REPLY: u32 = 0;
pub const RTE_IP_ICMP_ECHO_REQUEST: u32 = 8;
pub const RTE_ICMP6_ECHO_REQUEST: u32 = 128;
pub const RTE_ICMP6_ECHO_REPLY: u32 = 129;
pub const RTE_IPV4_MAX_PKT_LEN: u32 = 65535;
pub const RTE_IPV4_HDR_IHL_MASK: u32 = 15;
pub const RTE_IPV4_IHL_MULTIPLIER: u32 = 4;
pub const RTE_IPV4_HDR_DSCP_MASK: u32 = 252;
pub const RTE_IPV4_HDR_ECN_MASK: u32 = 3;
pub const RTE_IPV4_HDR_ECN_CE: u32 = 3;
pub const RTE_IPV4_HDR_DF_SHIFT: u32 = 14;
pub const RTE_IPV4_HDR_MF_SHIFT: u32 = 13;
pub const RTE_IPV4_HDR_FO_SHIFT: u32 = 3;
pub const RTE_IPV4_HDR_DF_FLAG: u32 = 16384;
pub const RTE_IPV4_HDR_MF_FLAG: u32 = 8192;
pub const RTE_IPV4_HDR_OFFSET_MASK: u32 = 8191;
pub const RTE_IPV4_HDR_OFFSET_UNITS: u32 = 8;
pub const RTE_IPV4_HDR_OPT_EOL: u32 = 0;
pub const RTE_IPV4_HDR_OPT_NOP: u32 = 1;
pub const RTE_IPV4_HDR_OPT_MAX_LEN: u32 = 40;
pub const RTE_IPV4_MIN_IHL: u32 = 5;
pub const RTE_IPV4_VHL_DEF: u32 = 69;
pub const RTE_IPV6_SRCRT_TYPE_4: u32 = 4;
pub const RTE_IPV6_HDR_FL_SHIFT: u32 = 0;
pub const RTE_IPV6_HDR_TC_SHIFT: u32 = 20;
pub const RTE_IPV6_HDR_FL_MASK: u32 = 1048575;
pub const RTE_IPV6_HDR_TC_MASK: u32 = 267386880;
pub const RTE_IPV6_HDR_DSCP_MASK: u32 = 264241152;
pub const RTE_IPV6_HDR_ECN_MASK: u32 = 3145728;
pub const RTE_IPV6_HDR_ECN_CE: u32 = 3145728;
pub const RTE_IPV6_MIN_MTU: u32 = 1280;
pub const RTE_IPV6_EHDR_MF_SHIFT: u32 = 0;
pub const RTE_IPV6_EHDR_MF_MASK: u32 = 1;
pub const RTE_IPV6_EHDR_FO_SHIFT: u32 = 3;
pub const RTE_IPV6_EHDR_FO_MASK: i32 = -8;
pub const RTE_IPV6_EHDR_FO_ALIGN: u32 = 8;
pub const RTE_IPV6_FRAG_USED_MASK: i32 = -7;
pub const RTE_TCP_CWR_FLAG: u32 = 128;
pub const RTE_TCP_ECE_FLAG: u32 = 64;
pub const RTE_TCP_URG_FLAG: u32 = 32;
pub const RTE_TCP_ACK_FLAG: u32 = 16;
pub const RTE_TCP_PSH_FLAG: u32 = 8;
pub const RTE_TCP_RST_FLAG: u32 = 4;
pub const RTE_TCP_SYN_FLAG: u32 = 2;
pub const RTE_TCP_FIN_FLAG: u32 = 1;
pub const RTE_VXLAN_DEFAULT_PORT: u32 = 4789;
pub const RTE_VXLAN_GPE_DEFAULT_PORT: u32 = 4790;
pub const RTE_VXLAN_GPE_TYPE_IPV4: u32 = 1;
pub const RTE_VXLAN_GPE_TYPE_IPV6: u32 = 2;
pub const RTE_VXLAN_GPE_TYPE_ETH: u32 = 3;
pub const RTE_VXLAN_GPE_TYPE_NSH: u32 = 4;
pub const RTE_VXLAN_GPE_TYPE_MPLS: u32 = 5;
pub const RTE_VXLAN_GPE_TYPE_GBP: u32 = 6;
pub const RTE_VXLAN_GPE_TYPE_VBNG: u32 = 7;
pub const RTE_ECPRI_REV_UP_TO_20: u32 = 1;
pub const RTE_ECPRI_MSG_TYPE_IQ_DATA: u32 = 0;
pub const RTE_ECPRI_MSG_TYPE_BIT_SEQ: u32 = 1;
pub const RTE_ECPRI_MSG_TYPE_RTC_CTRL: u32 = 2;
pub const RTE_ECPRI_MSG_TYPE_GEN_DATA: u32 = 3;
pub const RTE_ECPRI_MSG_TYPE_RM_ACC: u32 = 4;
pub const RTE_ECPRI_MSG_TYPE_DLY_MSR: u32 = 5;
pub const RTE_ECPRI_MSG_TYPE_RMT_RST: u32 = 6;
pub const RTE_ECPRI_MSG_TYPE_EVT_IND: u32 = 7;
pub const RTE_ECPRI_MSG_TYPE_IWF_UP: u32 = 8;
pub const RTE_ECPRI_MSG_TYPE_IWF_OPT: u32 = 9;
pub const RTE_ECPRI_MSG_TYPE_IWF_MAP: u32 = 10;
pub const RTE_ECPRI_MSG_TYPE_IWF_DCTRL: u32 = 11;
pub const RTE_ECPRI_EVT_IND_FAULT_IND: u32 = 0;
pub const RTE_ECPRI_EVT_IND_FAULT_ACK: u32 = 1;
pub const RTE_ECPRI_EVT_IND_NTFY_IND: u32 = 2;
pub const RTE_ECPRI_EVT_IND_SYNC_REQ: u32 = 3;
pub const RTE_ECPRI_EVT_IND_SYNC_ACK: u32 = 4;
pub const RTE_ECPRI_EVT_IND_SYNC_END: u32 = 5;
pub const RTE_MBUF_DYN_NAMESIZE: u32 = 64;
pub const RTE_MBUF_DYNFIELD_METADATA_NAME: &[u8; 27] = b"rte_flow_dynfield_metadata\0";
pub const RTE_MBUF_DYNFLAG_METADATA_NAME: &[u8; 26] = b"rte_flow_dynflag_metadata\0";
pub const RTE_MBUF_DYNFIELD_TIMESTAMP_NAME: &[u8; 23] = b"rte_dynfield_timestamp\0";
pub const RTE_MBUF_DYNFLAG_RX_TIMESTAMP_NAME: &[u8; 25] = b"rte_dynflag_rx_timestamp\0";
pub const RTE_MBUF_DYNFLAG_TX_TIMESTAMP_NAME: &[u8; 25] = b"rte_dynflag_tx_timestamp\0";
pub const RTE_MBUF_DYNFIELD_IP_REASSEMBLY_NAME: &[u8; 27] = b"rte_dynfield_ip_reassembly\0";
pub const RTE_MBUF_DYNFLAG_IP_REASSEMBLY_INCOMPLETE_NAME: &[u8; 37] =
    b"rte_dynflag_ip_reassembly_incomplete\0";
pub const RTE_GTP_TYPE_IPV4: u32 = 64;
pub const RTE_GTP_TYPE_IPV6: u32 = 96;
pub const RTE_GTPC_UDP_PORT: u32 = 2123;
pub const RTE_GTPU_UDP_PORT: u32 = 2152;
pub const RTE_L2TPV2_MSG_TYPE_CONTROL: u32 = 51202;
pub const RTE_L2TPV2_MSG_TYPE_DATA: u32 = 2;
pub const RTE_L2TPV2_MSG_TYPE_DATA_L: u32 = 16386;
pub const RTE_L2TPV2_MSG_TYPE_DATA_S: u32 = 2050;
pub const RTE_L2TPV2_MSG_TYPE_DATA_O: u32 = 514;
pub const RTE_L2TPV2_MSG_TYPE_DATA_L_S: u32 = 18434;
pub const RTE_L2TPV2_MSG_TYPE_DATA_L_O: u32 = 16898;
pub const RTE_L2TPV2_MSG_TYPE_DATA_S_O: u32 = 2562;
pub const RTE_L2TPV2_MSG_TYPE_DATA_L_S_O: u32 = 18946;
pub const RTE_MACSEC_TCI_VER_MASK: u32 = 128;
pub const RTE_MACSEC_TCI_ES: u32 = 64;
pub const RTE_MACSEC_TCI_SC: u32 = 32;
pub const RTE_MACSEC_TCI_SCB: u32 = 16;
pub const RTE_MACSEC_TCI_E: u32 = 8;
pub const RTE_MACSEC_TCI_C: u32 = 4;
pub const RTE_MACSEC_AN_MASK: u32 = 3;
pub const RTE_MACSEC_SCI_LEN: u32 = 8;
pub const RTE_ROCEV2_DEFAULT_PORT: u32 = 4791;
pub const RTE_NTUPLE_FLAGS_DST_IP: u32 = 1;
pub const RTE_NTUPLE_FLAGS_SRC_IP: u32 = 2;
pub const RTE_NTUPLE_FLAGS_DST_PORT: u32 = 4;
pub const RTE_NTUPLE_FLAGS_SRC_PORT: u32 = 8;
pub const RTE_NTUPLE_FLAGS_PROTO: u32 = 16;
pub const RTE_NTUPLE_FLAGS_TCP_FLAG: u32 = 32;
pub const RTE_5TUPLE_FLAGS: u32 = 31;
pub const RTE_2TUPLE_FLAGS: u32 = 20;
pub const RTE_NTUPLE_TCP_FLAGS_MASK: u32 = 63;
pub const RTE_ETH_FDIR_MAX_FLEXLEN: u32 = 16;
pub const RTE_ETH_INSET_SIZE_MAX: u32 = 128;
pub const RTE_ETH_DEV_FALLBACK_RX_RINGSIZE: u32 = 512;
pub const RTE_ETH_DEV_FALLBACK_TX_RINGSIZE: u32 = 512;
pub const RTE_ETH_DEV_FALLBACK_RX_NBQUEUES: u32 = 1;
pub const RTE_ETH_DEV_FALLBACK_TX_NBQUEUES: u32 = 1;
pub const RTE_ETH_DEV_SWITCH_DOMAIN_ID_INVALID: u32 = 65535;
pub const RTE_ETH_QUEUE_STATE_STOPPED: u32 = 0;
pub const RTE_ETH_QUEUE_STATE_STARTED: u32 = 1;
pub const RTE_ETH_QUEUE_STATE_HAIRPIN: u32 = 2;
pub const RTE_ETH_BURST_MODE_INFO_SIZE: u32 = 1024;
pub const RTE_ETH_XSTATS_NAME_SIZE: u32 = 64;
pub const RTE_ETH_DCB_NUM_TCS: u32 = 8;
pub const RTE_ETH_MAX_VMDQ_POOL: u32 = 64;
pub const RTE_ETH_ALL: u32 = 32;
pub const RTE_ETH_NAME_MAX_LEN: u32 = 64;
pub const RTE_ETH_DEV_NO_OWNER: u32 = 0;
pub const RTE_ETH_MAX_OWNER_NAME_LEN: u32 = 64;
pub const RTE_ETH_RX_DESC_AVAIL: u32 = 0;
pub const RTE_ETH_RX_DESC_DONE: u32 = 1;
pub const RTE_ETH_RX_DESC_UNAVAIL: u32 = 2;
pub const RTE_ETH_TX_DESC_FULL: u32 = 0;
pub const RTE_ETH_TX_DESC_DONE: u32 = 1;
pub const RTE_ETH_TX_DESC_UNAVAIL: u32 = 2;
pub const RTE_POWER_MAX_VFS: u32 = 10;
pub const RTE_POWER_VM_MAX_NAME_SZ: u32 = 32;
pub const RTE_POWER_MAX_VCPU_PER_VM: u32 = 8;
pub const RTE_POWER_HOURS_PER_DAY: u32 = 24;
pub const RTE_POWER_CPU_POWER: u32 = 1;
pub const RTE_POWER_CPU_POWER_CONNECT: u32 = 2;
pub const RTE_POWER_PKT_POLICY: u32 = 3;
pub const RTE_POWER_PKT_POLICY_REMOVE: u32 = 4;
pub const RTE_POWER_CORE_TYPE_VIRTUAL: u32 = 0;
pub const RTE_POWER_CORE_TYPE_PHYSICAL: u32 = 1;
pub const RTE_POWER_SCALE_UP: u32 = 1;
pub const RTE_POWER_SCALE_DOWN: u32 = 2;
pub const RTE_POWER_SCALE_MAX: u32 = 3;
pub const RTE_POWER_SCALE_MIN: u32 = 4;
pub const RTE_POWER_ENABLE_TURBO: u32 = 5;
pub const RTE_POWER_DISABLE_TURBO: u32 = 6;
pub const RTE_POWER_QUERY_FREQ_LIST: u32 = 7;
pub const RTE_POWER_QUERY_FREQ: u32 = 8;
pub const RTE_POWER_QUERY_CAPS_LIST: u32 = 9;
pub const RTE_POWER_QUERY_CAPS: u32 = 10;
pub const RTE_POWER_CMD_ACK: u32 = 1;
pub const RTE_POWER_CMD_NACK: u32 = 2;
pub const RTE_POWER_FREQ_LIST: u32 = 3;
pub const RTE_POWER_CAPS_LIST: u32 = 4;
extern "C" {
    #[doc = " Initialize the Environment Abstraction Layer (EAL).\n\n This function is to be executed on the MAIN lcore only, as soon\n as possible in the application's main() function.\n It puts the WORKER lcores in the WAIT state.\n\n @param argc\n   A non-negative value.  If it is greater than 0, the array members\n   for argv[0] through argv[argc] (non-inclusive) shall contain pointers\n   to strings.\n @param argv\n   An array of strings.  The contents of the array, as well as the strings\n   which are pointed to by the array, may be modified by this function.\n   The program name pointer argv[0] is copied into the last parsed argv\n   so that argv[0] is still the same after deducing the parsed arguments.\n @return\n   - On success, the number of parsed arguments, which is greater or\n     equal to zero. After the call to rte_eal_init(),\n     all arguments argv[x] with x < ret may have been modified by this\n     function call and should not be further interpreted by the\n     application.  The EAL does not take any ownership of the memory used\n     for either the argv array, or its members.\n   - On failure, -1 and rte_errno is set to a value indicating the cause\n     for failure.  In some instances, the application will need to be\n     restarted as part of clearing the issue.\n\n   Error codes returned via rte_errno:\n     EACCES indicates a permissions issue.\n\n     EAGAIN indicates either a bus or system resource was not available,\n            setup may be attempted again.\n\n     EALREADY indicates that the rte_eal_init function has already been\n              called, and cannot be called again.\n\n     EFAULT indicates the tailq configuration name was not found in\n            memory configuration.\n\n     EINVAL indicates invalid parameters were passed as argv/argc.\n\n     ENOMEM indicates failure likely caused by an out-of-memory condition.\n\n     ENODEV indicates memory setup issues.\n\n     ENOTSUP indicates that the EAL cannot initialize on this system.\n\n     EPROTO indicates that the PCI bus is either not present, or is not\n            readable by the eal.\n\n     ENOEXEC indicates that a service core failed to launch successfully."]
    pub fn rte_eal_init(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Clean up the Environment Abstraction Layer (EAL)\n\n This function must be called to release any internal resources that EAL has\n allocated during rte_eal_init(). After this call, no DPDK function calls may\n be made. It is expected that common usage of this function is to call it\n just before terminating the process.\n\n @return\n  - 0 Successfully released all internal EAL resources.\n  - -EFAULT There was an error in releasing all resources."]
    pub fn rte_eal_cleanup() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function which returns a printable string describing a particular\n error code. For non-RTE-specific error codes, this function returns\n the value from the libc strerror function.\n\n @param errnum\n   The error number to be looked up - generally the value of rte_errno\n @return\n   A pointer to a thread-local string containing the text describing\n   the error."]
    pub fn rte_strerror(errnum: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
#[doc = "< Start numbering above std errno vals"]
pub const RTE_MIN_ERRNO: _bindgen_ty_1 = 1000;
#[doc = "< Operation not allowed in secondary processes"]
pub const E_RTE_SECONDARY: _bindgen_ty_1 = 1001;
#[doc = "< Missing rte_config"]
pub const E_RTE_NO_CONFIG: _bindgen_ty_1 = 1002;
#[doc = "< Max RTE error number"]
pub const RTE_MAX_ERRNO: _bindgen_ty_1 = 1003;
#[doc = " Error types"]
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
#[doc = " IO virtual address type.\n When the physical addressing mode (IOVA as PA) is in use,\n the translation from an IO virtual address (IOVA) to a physical address\n is a direct mapping, i.e. the same value.\n Otherwise, in virtual mode (IOVA as VA), an IOMMU may do the translation."]
pub type rte_iova_t = u64;
#[doc = " Generic marker for any place in a structure."]
pub type RTE_MARKER = [*mut ::std::os::raw::c_void; 0usize];
#[doc = " Marker for 8B alignment in a structure."]
pub type RTE_MARKER64 = [u64; 0usize];
pub const RTE_EPOLL_INVALID: _bindgen_ty_2 = 0;
pub const RTE_EPOLL_VALID: _bindgen_ty_2 = 1;
pub const RTE_EPOLL_EXEC: _bindgen_ty_2 = 2;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_device {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Get the id of the main lcore\n\n @return\n   the id of the main lcore"]
    pub fn rte_get_main_lcore() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Return the number of execution units (lcores) on the system.\n\n @return\n   the number of execution units (lcores) on the system."]
    pub fn rte_lcore_count() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Register current non-EAL thread as a lcore.\n\n @note This API is not compatible with the multi-process feature:\n - if a primary process registers a non-EAL thread, then no secondary process\n   will initialise.\n - if a secondary process initialises successfully, trying to register a\n   non-EAL thread from either primary or secondary processes will always end\n   up with the thread getting LCORE_ID_ANY as lcore.\n\n @return\n   On success, return 0; otherwise return -1 with rte_errno set."]
    pub fn rte_thread_register() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Unregister current thread and release lcore if one was associated."]
    pub fn rte_thread_unregister();
}
#[doc = " A structure used to retrieve statistics for an Ethernet port.\n Not all statistics fields in struct rte_eth_stats are supported\n by any type of network interface card (NIC). If any statistics\n field is not supported, its value is 0.\n All byte-related statistics do not include Ethernet FCS regardless\n of whether these bytes have been delivered to the application\n (see RTE_ETH_RX_OFFLOAD_KEEP_CRC)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_stats {
    #[doc = "< Total number of successfully received packets."]
    pub ipackets: u64,
    #[doc = "< Total number of successfully transmitted packets."]
    pub opackets: u64,
    #[doc = "< Total number of successfully received bytes."]
    pub ibytes: u64,
    #[doc = "< Total number of successfully transmitted bytes."]
    pub obytes: u64,
    #[doc = " Total of Rx packets dropped by the HW,\n because there are no available buffer (i.e. Rx queues are full)."]
    pub imissed: u64,
    #[doc = "< Total number of erroneous received packets."]
    pub ierrors: u64,
    #[doc = "< Total number of failed transmitted packets."]
    pub oerrors: u64,
    #[doc = "< Total number of Rx mbuf allocation failures."]
    pub rx_nombuf: u64,
    #[doc = " Total number of queue Rx packets."]
    pub q_ipackets: [u64; 16usize],
    #[doc = " Total number of queue Tx packets."]
    pub q_opackets: [u64; 16usize],
    #[doc = " Total number of successfully received queue bytes."]
    pub q_ibytes: [u64; 16usize],
    #[doc = " Total number of successfully transmitted queue bytes."]
    pub q_obytes: [u64; 16usize],
    #[doc = " Total number of queue packets received that are dropped."]
    pub q_errors: [u64; 16usize],
}
#[test]
fn bindgen_test_layout_rte_eth_stats() {
    const UNINIT: ::std::mem::MaybeUninit<rte_eth_stats> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_eth_stats>(),
        704usize,
        concat!("Size of: ", stringify!(rte_eth_stats))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_stats>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_stats))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipackets) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(ipackets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opackets) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(opackets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ibytes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(ibytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).obytes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(obytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imissed) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(imissed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ierrors) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(ierrors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).oerrors) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(oerrors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_nombuf) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(rx_nombuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).q_ipackets) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(q_ipackets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).q_opackets) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(q_opackets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).q_ibytes) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(q_ibytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).q_obytes) as usize - ptr as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(q_obytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).q_errors) as usize - ptr as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_stats),
            "::",
            stringify!(q_errors)
        )
    );
}
#[doc = " A structure used to configure the ring threshold registers of an Rx/Tx\n queue for an Ethernet port."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_thresh {
    #[doc = "< Ring prefetch threshold."]
    pub pthresh: u8,
    #[doc = "< Ring host threshold."]
    pub hthresh: u8,
    #[doc = "< Ring writeback threshold."]
    pub wthresh: u8,
}
#[test]
fn bindgen_test_layout_rte_eth_thresh() {
    const UNINIT: ::std::mem::MaybeUninit<rte_eth_thresh> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_eth_thresh>(),
        3usize,
        concat!("Size of: ", stringify!(rte_eth_thresh))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_thresh>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_eth_thresh))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pthresh) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_thresh),
            "::",
            stringify!(pthresh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hthresh) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_thresh),
            "::",
            stringify!(hthresh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wthresh) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_thresh),
            "::",
            stringify!(wthresh)
        )
    );
}
#[doc = " None of DCB, RSS or VMDq mode"]
pub const rte_eth_rx_mq_mode_RTE_ETH_MQ_RX_NONE: rte_eth_rx_mq_mode = 0;
#[doc = " For Rx side, only RSS is on"]
pub const rte_eth_rx_mq_mode_RTE_ETH_MQ_RX_RSS: rte_eth_rx_mq_mode = 1;
#[doc = " For Rx side,only DCB is on."]
pub const rte_eth_rx_mq_mode_RTE_ETH_MQ_RX_DCB: rte_eth_rx_mq_mode = 2;
#[doc = " Both DCB and RSS enable"]
pub const rte_eth_rx_mq_mode_RTE_ETH_MQ_RX_DCB_RSS: rte_eth_rx_mq_mode = 3;
#[doc = " Only VMDq, no RSS nor DCB"]
pub const rte_eth_rx_mq_mode_RTE_ETH_MQ_RX_VMDQ_ONLY: rte_eth_rx_mq_mode = 4;
#[doc = " RSS mode with VMDq"]
pub const rte_eth_rx_mq_mode_RTE_ETH_MQ_RX_VMDQ_RSS: rte_eth_rx_mq_mode = 5;
#[doc = " Use VMDq+DCB to route traffic to queues"]
pub const rte_eth_rx_mq_mode_RTE_ETH_MQ_RX_VMDQ_DCB: rte_eth_rx_mq_mode = 6;
#[doc = " Enable both VMDq and DCB in VMDq"]
pub const rte_eth_rx_mq_mode_RTE_ETH_MQ_RX_VMDQ_DCB_RSS: rte_eth_rx_mq_mode = 7;
#[doc = "  A set of values to identify what method is to be used to route\n  packets to multiple queues."]
pub type rte_eth_rx_mq_mode = ::std::os::raw::c_uint;
#[doc = "< It is in neither DCB nor VT mode."]
pub const rte_eth_tx_mq_mode_RTE_ETH_MQ_TX_NONE: rte_eth_tx_mq_mode = 0;
#[doc = "< For Tx side,only DCB is on."]
pub const rte_eth_tx_mq_mode_RTE_ETH_MQ_TX_DCB: rte_eth_tx_mq_mode = 1;
#[doc = "< For Tx side,both DCB and VT is on."]
pub const rte_eth_tx_mq_mode_RTE_ETH_MQ_TX_VMDQ_DCB: rte_eth_tx_mq_mode = 2;
#[doc = "< Only VT on, no DCB"]
pub const rte_eth_tx_mq_mode_RTE_ETH_MQ_TX_VMDQ_ONLY: rte_eth_tx_mq_mode = 3;
#[doc = " A set of values to identify what method is to be used to transmit\n packets using multi-TCs."]
pub type rte_eth_tx_mq_mode = ::std::os::raw::c_uint;
#[doc = " A structure used to configure the Rx features of an Ethernet port."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_rxmode {
    #[doc = " The multi-queue packet distribution mode to be used, e.g. RSS."]
    pub mq_mode: rte_eth_rx_mq_mode,
    #[doc = "< Requested MTU."]
    pub mtu: u32,
    #[doc = " Maximum allowed size of LRO aggregated packet."]
    pub max_lro_pkt_size: u32,
    #[doc = " Per-port Rx offloads to be set using RTE_ETH_RX_OFFLOAD_* flags.\n Only offloads set on rx_offload_capa field on rte_eth_dev_info\n structure are allowed to be set."]
    pub offloads: u64,
    #[doc = "< Reserved for future fields"]
    pub reserved_64s: [u64; 2usize],
    #[doc = "< Reserved for future fields"]
    pub reserved_ptrs: [*mut ::std::os::raw::c_void; 2usize],
}
#[test]
fn bindgen_test_layout_rte_eth_rxmode() {
    const UNINIT: ::std::mem::MaybeUninit<rte_eth_rxmode> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_eth_rxmode>(),
        56usize,
        concat!("Size of: ", stringify!(rte_eth_rxmode))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_rxmode>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_rxmode))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mq_mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxmode),
            "::",
            stringify!(mq_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mtu) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxmode),
            "::",
            stringify!(mtu)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_lro_pkt_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxmode),
            "::",
            stringify!(max_lro_pkt_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offloads) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxmode),
            "::",
            stringify!(offloads)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved_64s) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxmode),
            "::",
            stringify!(reserved_64s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved_ptrs) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxmode),
            "::",
            stringify!(reserved_ptrs)
        )
    );
}
#[doc = " DEFAULT means driver decides which hash algorithm to pick."]
pub const rte_eth_hash_function_RTE_ETH_HASH_FUNCTION_DEFAULT: rte_eth_hash_function = 0;
#[doc = "< Toeplitz"]
pub const rte_eth_hash_function_RTE_ETH_HASH_FUNCTION_TOEPLITZ: rte_eth_hash_function = 1;
#[doc = "< Simple XOR"]
pub const rte_eth_hash_function_RTE_ETH_HASH_FUNCTION_SIMPLE_XOR: rte_eth_hash_function = 2;
#[doc = " Symmetric Toeplitz: src, dst will be replaced by\n xor(src, dst). For the case with src/dst only,\n src or dst address will xor with zero pair."]
pub const rte_eth_hash_function_RTE_ETH_HASH_FUNCTION_SYMMETRIC_TOEPLITZ: rte_eth_hash_function = 3;
#[doc = " Symmetric Toeplitz: L3 and L4 fields are sorted prior to\n the hash function.\n  If src_ip > dst_ip, swap src_ip and dst_ip.\n  If src_port > dst_port, swap src_port and dst_port."]
pub const rte_eth_hash_function_RTE_ETH_HASH_FUNCTION_SYMMETRIC_TOEPLITZ_SORT:
    rte_eth_hash_function = 4;
#[doc = " Symmetric Toeplitz: L3 and L4 fields are sorted prior to\n the hash function.\n  If src_ip > dst_ip, swap src_ip and dst_ip.\n  If src_port > dst_port, swap src_port and dst_port."]
pub const rte_eth_hash_function_RTE_ETH_HASH_FUNCTION_MAX: rte_eth_hash_function = 5;
#[doc = " Hash function types."]
pub type rte_eth_hash_function = ::std::os::raw::c_uint;
#[doc = " A structure used to configure the Receive Side Scaling (RSS) feature\n of an Ethernet port."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_rss_conf {
    #[doc = " In rte_eth_dev_rss_hash_conf_get(), the *rss_key_len* should be\n greater than or equal to the *hash_key_size* which get from\n rte_eth_dev_info_get() API. And the *rss_key* should contain at least\n *hash_key_size* bytes. If not meet these requirements, the query\n result is unreliable even if the operation returns success.\n\n In rte_eth_dev_rss_hash_update() or rte_eth_dev_configure(), if\n *rss_key* is not NULL, the *rss_key_len* indicates the length of the\n *rss_key* in bytes and it should be equal to *hash_key_size*.\n If *rss_key* is NULL, drivers are free to use a random or a default key."]
    pub rss_key: *mut u8,
    #[doc = "< hash key length in bytes."]
    pub rss_key_len: u8,
    #[doc = " Indicates the type of packets or the specific part of packets to\n which RSS hashing is to be applied."]
    pub rss_hf: u64,
    #[doc = "< Hash algorithm."]
    pub algorithm: rte_eth_hash_function,
}
#[test]
fn bindgen_test_layout_rte_eth_rss_conf() {
    const UNINIT: ::std::mem::MaybeUninit<rte_eth_rss_conf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_eth_rss_conf>(),
        32usize,
        concat!("Size of: ", stringify!(rte_eth_rss_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_rss_conf>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_rss_conf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rss_key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rss_conf),
            "::",
            stringify!(rss_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rss_key_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rss_conf),
            "::",
            stringify!(rss_key_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rss_hf) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rss_conf),
            "::",
            stringify!(rss_hf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).algorithm) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rss_conf),
            "::",
            stringify!(algorithm)
        )
    );
}
#[doc = "< 4 TCs with DCB."]
pub const rte_eth_nb_tcs_RTE_ETH_4_TCS: rte_eth_nb_tcs = 4;
#[doc = "< 8 TCs with DCB."]
pub const rte_eth_nb_tcs_RTE_ETH_8_TCS: rte_eth_nb_tcs = 8;
#[doc = " This enum indicates the possible number of traffic classes\n in DCB configurations"]
pub type rte_eth_nb_tcs = ::std::os::raw::c_uint;
#[doc = "< 8 VMDq pools."]
pub const rte_eth_nb_pools_RTE_ETH_8_POOLS: rte_eth_nb_pools = 8;
#[doc = "< 16 VMDq pools."]
pub const rte_eth_nb_pools_RTE_ETH_16_POOLS: rte_eth_nb_pools = 16;
#[doc = "< 32 VMDq pools."]
pub const rte_eth_nb_pools_RTE_ETH_32_POOLS: rte_eth_nb_pools = 32;
#[doc = "< 64 VMDq pools."]
pub const rte_eth_nb_pools_RTE_ETH_64_POOLS: rte_eth_nb_pools = 64;
#[doc = " This enum indicates the possible number of queue pools\n in VMDq configurations."]
pub type rte_eth_nb_pools = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dcb_rx_conf {
    #[doc = "< Possible DCB TCs, 4 or 8 TCs"]
    pub nb_tcs: rte_eth_nb_tcs,
    #[doc = " Traffic class each UP mapped to."]
    pub dcb_tc: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_rte_eth_dcb_rx_conf() {
    const UNINIT: ::std::mem::MaybeUninit<rte_eth_dcb_rx_conf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dcb_rx_conf>(),
        12usize,
        concat!("Size of: ", stringify!(rte_eth_dcb_rx_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dcb_rx_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_dcb_rx_conf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_tcs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_rx_conf),
            "::",
            stringify!(nb_tcs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dcb_tc) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_rx_conf),
            "::",
            stringify!(dcb_tc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_vmdq_dcb_tx_conf {
    #[doc = "< With DCB, 16 or 32 pools."]
    pub nb_queue_pools: rte_eth_nb_pools,
    #[doc = " Traffic class each UP mapped to."]
    pub dcb_tc: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_dcb_tx_conf() {
    const UNINIT: ::std::mem::MaybeUninit<rte_eth_vmdq_dcb_tx_conf> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_eth_vmdq_dcb_tx_conf>(),
        12usize,
        concat!("Size of: ", stringify!(rte_eth_vmdq_dcb_tx_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_vmdq_dcb_tx_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_vmdq_dcb_tx_conf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_queue_pools) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_tx_conf),
            "::",
            stringify!(nb_queue_pools)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dcb_tc) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_tx_conf),
            "::",
            stringify!(dcb_tc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dcb_tx_conf {
    #[doc = "< Possible DCB TCs, 4 or 8 TCs."]
    pub nb_tcs: rte_eth_nb_tcs,
    #[doc = " Traffic class each UP mapped to."]
    pub dcb_tc: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_rte_eth_dcb_tx_conf() {
    const UNINIT: ::std::mem::MaybeUninit<rte_eth_dcb_tx_conf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dcb_tx_conf>(),
        12usize,
        concat!("Size of: ", stringify!(rte_eth_dcb_tx_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dcb_tx_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_dcb_tx_conf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_tcs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_tx_conf),
            "::",
            stringify!(nb_tcs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dcb_tc) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dcb_tx_conf),
            "::",
            stringify!(dcb_tc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_vmdq_tx_conf {
    #[doc = "< VMDq mode, 64 pools."]
    pub nb_queue_pools: rte_eth_nb_pools,
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_tx_conf() {
    const UNINIT: ::std::mem::MaybeUninit<rte_eth_vmdq_tx_conf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_eth_vmdq_tx_conf>(),
        4usize,
        concat!("Size of: ", stringify!(rte_eth_vmdq_tx_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_vmdq_tx_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_vmdq_tx_conf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_queue_pools) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_tx_conf),
            "::",
            stringify!(nb_queue_pools)
        )
    );
}
#[doc = " A structure used to configure the VMDq+DCB feature\n of an Ethernet port.\n\n Using this feature, packets are routed to a pool of queues, based\n on the VLAN ID in the VLAN tag, and then to a specific queue within\n that pool, using the user priority VLAN tag field.\n\n A default pool may be used, if desired, to route all traffic which\n does not match the VLAN filter rules."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_vmdq_dcb_conf {
    #[doc = "< With DCB, 16 or 32 pools"]
    pub nb_queue_pools: rte_eth_nb_pools,
    #[doc = "< If non-zero, use a default pool"]
    pub enable_default_pool: u8,
    #[doc = "< The default pool, if applicable"]
    pub default_pool: u8,
    #[doc = "< We can have up to 64 filters/mappings"]
    pub nb_pool_maps: u8,
    #[doc = "< VMDq VLAN pool maps."]
    pub pool_map: [rte_eth_vmdq_dcb_conf__bindgen_ty_1; 64usize],
    #[doc = " Selects a queue in a pool"]
    pub dcb_tc: [u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_vmdq_dcb_conf__bindgen_ty_1 {
    #[doc = "< The VLAN ID of the received frame"]
    pub vlan_id: u16,
    #[doc = "< Bitmask of pools for packet Rx"]
    pub pools: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_dcb_conf__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<rte_eth_vmdq_dcb_conf__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_eth_vmdq_dcb_conf__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_vmdq_dcb_conf__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_vmdq_dcb_conf__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rte_eth_vmdq_dcb_conf__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vlan_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf__bindgen_ty_1),
            "::",
            stringify!(vlan_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pools) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf__bindgen_ty_1),
            "::",
            stringify!(pools)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_dcb_conf() {
    const UNINIT: ::std::mem::MaybeUninit<rte_eth_vmdq_dcb_conf> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_eth_vmdq_dcb_conf>(),
        1040usize,
        concat!("Size of: ", stringify!(rte_eth_vmdq_dcb_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_vmdq_dcb_conf>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_vmdq_dcb_conf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_queue_pools) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf),
            "::",
            stringify!(nb_queue_pools)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable_default_pool) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf),
            "::",
            stringify!(enable_default_pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_pool) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf),
            "::",
            stringify!(default_pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_pool_maps) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf),
            "::",
            stringify!(nb_pool_maps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pool_map) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf),
            "::",
            stringify!(pool_map)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dcb_tc) as usize - ptr as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_dcb_conf),
            "::",
            stringify!(dcb_tc)
        )
    );
}
#[doc = " A structure used to configure the VMDq feature of an Ethernet port when\n not combined with the DCB feature.\n\n Using this feature, packets are routed to a pool of queues. By default,\n the pool selection is based on the MAC address, the VLAN ID in the\n VLAN tag as specified in the pool_map array.\n Passing the RTE_ETH_VMDQ_ACCEPT_UNTAG in the rx_mode field allows pool\n selection using only the MAC address. MAC address to pool mapping is done\n using the rte_eth_dev_mac_addr_add function, with the pool parameter\n corresponding to the pool ID.\n\n Queue selection within the selected pool will be done using RSS when\n it is enabled or revert to the first queue of the pool if not.\n\n A default pool may be used, if desired, to route all traffic which\n does not match the VLAN filter rules or any pool MAC address."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_vmdq_rx_conf {
    #[doc = "< VMDq only mode, 8 or 64 pools"]
    pub nb_queue_pools: rte_eth_nb_pools,
    #[doc = "< If non-zero, use a default pool"]
    pub enable_default_pool: u8,
    #[doc = "< The default pool, if applicable"]
    pub default_pool: u8,
    #[doc = "< Enable VT loop back"]
    pub enable_loop_back: u8,
    #[doc = "< We can have up to 64 filters/mappings"]
    pub nb_pool_maps: u8,
    #[doc = "< Flags from RTE_ETH_VMDQ_ACCEPT_*"]
    pub rx_mode: u32,
    #[doc = "< VMDq VLAN pool maps."]
    pub pool_map: [rte_eth_vmdq_rx_conf__bindgen_ty_1; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_vmdq_rx_conf__bindgen_ty_1 {
    #[doc = "< The VLAN ID of the received frame"]
    pub vlan_id: u16,
    #[doc = "< Bitmask of pools for packet Rx"]
    pub pools: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_rx_conf__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<rte_eth_vmdq_rx_conf__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_eth_vmdq_rx_conf__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_vmdq_rx_conf__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_vmdq_rx_conf__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rte_eth_vmdq_rx_conf__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vlan_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf__bindgen_ty_1),
            "::",
            stringify!(vlan_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pools) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf__bindgen_ty_1),
            "::",
            stringify!(pools)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_eth_vmdq_rx_conf() {
    const UNINIT: ::std::mem::MaybeUninit<rte_eth_vmdq_rx_conf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_eth_vmdq_rx_conf>(),
        1040usize,
        concat!("Size of: ", stringify!(rte_eth_vmdq_rx_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_vmdq_rx_conf>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_vmdq_rx_conf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_queue_pools) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf),
            "::",
            stringify!(nb_queue_pools)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable_default_pool) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf),
            "::",
            stringify!(enable_default_pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_pool) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf),
            "::",
            stringify!(default_pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable_loop_back) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf),
            "::",
            stringify!(enable_loop_back)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_pool_maps) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf),
            "::",
            stringify!(nb_pool_maps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_mode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf),
            "::",
            stringify!(rx_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pool_map) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_vmdq_rx_conf),
            "::",
            stringify!(pool_map)
        )
    );
}
#[doc = " A structure used to configure the Tx features of an Ethernet port."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_txmode {
    #[doc = "< Tx multi-queues mode."]
    pub mq_mode: rte_eth_tx_mq_mode,
    #[doc = " Per-port Tx offloads to be set using RTE_ETH_TX_OFFLOAD_* flags.\n Only offloads set on tx_offload_capa field on rte_eth_dev_info\n structure are allowed to be set."]
    pub offloads: u64,
    pub pvid: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Reserved for future fields"]
    pub reserved_64s: [u64; 2usize],
    #[doc = "< Reserved for future fields"]
    pub reserved_ptrs: [*mut ::std::os::raw::c_void; 2usize],
}
#[test]
fn bindgen_test_layout_rte_eth_txmode() {
    const UNINIT: ::std::mem::MaybeUninit<rte_eth_txmode> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_eth_txmode>(),
        56usize,
        concat!("Size of: ", stringify!(rte_eth_txmode))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_txmode>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_txmode))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mq_mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txmode),
            "::",
            stringify!(mq_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offloads) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txmode),
            "::",
            stringify!(offloads)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pvid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txmode),
            "::",
            stringify!(pvid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved_64s) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txmode),
            "::",
            stringify!(reserved_64s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved_ptrs) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txmode),
            "::",
            stringify!(reserved_ptrs)
        )
    );
}
impl rte_eth_txmode {
    #[inline]
    pub fn hw_vlan_reject_tagged(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hw_vlan_reject_tagged(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hw_vlan_reject_untagged(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hw_vlan_reject_untagged(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hw_vlan_insert_pvid(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hw_vlan_insert_pvid(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hw_vlan_reject_tagged: u8,
        hw_vlan_reject_untagged: u8,
        hw_vlan_insert_pvid: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hw_vlan_reject_tagged: u8 = unsafe { ::std::mem::transmute(hw_vlan_reject_tagged) };
            hw_vlan_reject_tagged as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let hw_vlan_reject_untagged: u8 =
                unsafe { ::std::mem::transmute(hw_vlan_reject_untagged) };
            hw_vlan_reject_untagged as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hw_vlan_insert_pvid: u8 = unsafe { ::std::mem::transmute(hw_vlan_insert_pvid) };
            hw_vlan_insert_pvid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice.\n\n A structure used to configure an Rx packet segment to split.\n\n If RTE_ETH_RX_OFFLOAD_BUFFER_SPLIT flag is set in offloads field,\n the PMD will split the received packets into multiple segments\n according to the specification in the description array:\n\n - The first network buffer will be allocated from the memory pool,\n   specified in the first array element, the second buffer, from the\n   pool in the second element, and so on.\n\n - The proto_hdrs in the elements define the split position of\n   received packets.\n\n - The offsets from the segment description elements specify\n   the data offset from the buffer beginning except the first mbuf.\n   The first segment offset is added with RTE_PKTMBUF_HEADROOM.\n\n - The lengths in the elements define the maximal data amount\n   being received to each segment. The receiving starts with filling\n   up the first mbuf data buffer up to specified length. If the\n   there are data remaining (packet is longer than buffer in the first\n   mbuf) the following data will be pushed to the next segment\n   up to its own length, and so on.\n\n - If the length in the segment description element is zero\n   the actual buffer size will be deduced from the appropriate\n   memory pool properties.\n\n - If there is not enough elements to describe the buffer for entire\n   packet of maximal length the following parameters will be used\n   for the all remaining segments:\n     - pool from the last valid element\n     - the buffer size from this pool\n     - zero offset\n\n - Length based buffer split:\n     - mp, length, offset should be configured.\n     - The proto_hdr field must be 0.\n\n - Protocol header based buffer split:\n     - mp, offset, proto_hdr should be configured.\n     - The length field must be 0.\n     - The proto_hdr field in the last segment should be 0.\n\n - When protocol header split is enabled, NIC may receive packets\n   which do not match all the protocol headers within the Rx segments.\n   At this point, NIC will have two possible split behaviors according to\n   matching results, one is exact match, another is longest match.\n   The split result of NIC must belong to one of them.\n   The exact match means NIC only do split when the packets exactly match all\n   the protocol headers in the segments.\n   Otherwise, the whole packet will be put into the last valid mempool.\n   The longest match means NIC will do split until packets mismatch\n   the protocol header in the segments.\n   The rest will be put into the last valid pool."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_rxseg_split {
    #[doc = "< Memory pool to allocate segment from."]
    pub mp: *mut rte_mempool,
    #[doc = "< Segment data length, configures split point."]
    pub length: u16,
    #[doc = "< Data offset from beginning of mbuf data buffer."]
    pub offset: u16,
    #[doc = " proto_hdr defines a bit mask of the protocol sequence as RTE_PTYPE_*.\n The last RTE_PTYPE* in the mask indicates the split position.\n\n If one protocol header is defined to split packets into two segments,\n for non-tunneling packets, the complete protocol sequence should be defined.\n For tunneling packets, for simplicity, only the tunnel and inner part of\n complete protocol sequence is required.\n If several protocol headers are defined to split packets into multi-segments,\n the repeated parts of adjacent segments should be omitted."]
    pub proto_hdr: u32,
}
#[test]
fn bindgen_test_layout_rte_eth_rxseg_split() {
    const UNINIT: ::std::mem::MaybeUninit<rte_eth_rxseg_split> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_eth_rxseg_split>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_rxseg_split))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_rxseg_split>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_rxseg_split))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxseg_split),
            "::",
            stringify!(mp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxseg_split),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxseg_split),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proto_hdr) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxseg_split),
            "::",
            stringify!(proto_hdr)
        )
    );
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice.\n\n A common structure used to describe Rx packet segment properties."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_rxseg {
    pub split: rte_eth_rxseg_split,
}
#[test]
fn bindgen_test_layout_rte_eth_rxseg() {
    const UNINIT: ::std::mem::MaybeUninit<rte_eth_rxseg> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_eth_rxseg>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_rxseg))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_rxseg>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_rxseg))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).split) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxseg),
            "::",
            stringify!(split)
        )
    );
}
#[doc = " A structure used to configure an Rx ring of an Ethernet port."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_rxconf {
    #[doc = "< Rx ring threshold registers."]
    pub rx_thresh: rte_eth_thresh,
    #[doc = "< Drives the freeing of Rx descriptors."]
    pub rx_free_thresh: u16,
    #[doc = "< Drop packets if no descriptors are available."]
    pub rx_drop_en: u8,
    #[doc = "< Do not start queue with rte_eth_dev_start()."]
    pub rx_deferred_start: u8,
    #[doc = "< Number of descriptions in rx_seg array."]
    pub rx_nseg: u16,
    #[doc = " Share group index in Rx domain and switch domain.\n Non-zero value to enable Rx queue share, zero value disable share.\n PMD is responsible for Rx queue consistency checks to avoid member\n port's configuration contradict to each other."]
    pub share_group: u16,
    #[doc = "< Shared Rx queue ID in group"]
    pub share_qid: u16,
    #[doc = " Per-queue Rx offloads to be set using RTE_ETH_RX_OFFLOAD_* flags.\n Only offloads set on rx_queue_offload_capa or rx_offload_capa\n fields on rte_eth_dev_info structure are allowed to be set."]
    pub offloads: u64,
    #[doc = " Points to the array of segment descriptions for an entire packet.\n Array elements are properties for consecutive Rx segments.\n\n The supported capabilities of receiving segmentation is reported\n in rte_eth_dev_info.rx_seg_capa field."]
    pub rx_seg: *mut rte_eth_rxseg,
    #[doc = " Array of mempools to allocate Rx buffers from.\n\n This provides support for multiple mbuf pools per Rx queue.\n The capability is reported in device info via positive\n max_rx_mempools.\n\n It could be useful for more efficient usage of memory when an\n application creates different mempools to steer the specific\n size of the packet.\n\n If many mempools are specified, packets received using Rx\n burst may belong to any provided mempool. From ethdev user point\n of view it is undefined how PMD/NIC chooses mempool for a packet.\n\n If Rx scatter is enabled, a packet may be delivered using a chain\n of mbufs obtained from single mempool or multiple mempools based\n on the NIC implementation."]
    pub rx_mempools: *mut *mut rte_mempool,
    pub rx_nmempool: u16,
    #[doc = "< Reserved for future fields"]
    pub reserved_64s: [u64; 2usize],
    #[doc = "< Reserved for future fields"]
    pub reserved_ptrs: [*mut ::std::os::raw::c_void; 2usize],
}
#[test]
fn bindgen_test_layout_rte_eth_rxconf() {
    const UNINIT: ::std::mem::MaybeUninit<rte_eth_rxconf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_eth_rxconf>(),
        80usize,
        concat!("Size of: ", stringify!(rte_eth_rxconf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_rxconf>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_rxconf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_thresh) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxconf),
            "::",
            stringify!(rx_thresh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_free_thresh) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxconf),
            "::",
            stringify!(rx_free_thresh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_drop_en) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxconf),
            "::",
            stringify!(rx_drop_en)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_deferred_start) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxconf),
            "::",
            stringify!(rx_deferred_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_nseg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxconf),
            "::",
            stringify!(rx_nseg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).share_group) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxconf),
            "::",
            stringify!(share_group)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).share_qid) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxconf),
            "::",
            stringify!(share_qid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offloads) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxconf),
            "::",
            stringify!(offloads)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_seg) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxconf),
            "::",
            stringify!(rx_seg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_mempools) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxconf),
            "::",
            stringify!(rx_mempools)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_nmempool) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxconf),
            "::",
            stringify!(rx_nmempool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved_64s) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxconf),
            "::",
            stringify!(reserved_64s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved_ptrs) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxconf),
            "::",
            stringify!(reserved_ptrs)
        )
    );
}
#[doc = " A structure used to configure a Tx ring of an Ethernet port."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_txconf {
    #[doc = "< Tx ring threshold registers."]
    pub tx_thresh: rte_eth_thresh,
    #[doc = "< Drives the setting of RS bit on TXDs."]
    pub tx_rs_thresh: u16,
    #[doc = "< Start freeing Tx buffers if there are\nless free descriptors than this value."]
    pub tx_free_thresh: u16,
    #[doc = "< Do not start queue with rte_eth_dev_start()."]
    pub tx_deferred_start: u8,
    #[doc = " Per-queue Tx offloads to be set  using RTE_ETH_TX_OFFLOAD_* flags.\n Only offloads set on tx_queue_offload_capa or tx_offload_capa\n fields on rte_eth_dev_info structure are allowed to be set."]
    pub offloads: u64,
    #[doc = "< Reserved for future fields"]
    pub reserved_64s: [u64; 2usize],
    #[doc = "< Reserved for future fields"]
    pub reserved_ptrs: [*mut ::std::os::raw::c_void; 2usize],
}
#[test]
fn bindgen_test_layout_rte_eth_txconf() {
    const UNINIT: ::std::mem::MaybeUninit<rte_eth_txconf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_eth_txconf>(),
        56usize,
        concat!("Size of: ", stringify!(rte_eth_txconf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_txconf>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_txconf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_thresh) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txconf),
            "::",
            stringify!(tx_thresh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_rs_thresh) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txconf),
            "::",
            stringify!(tx_rs_thresh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_free_thresh) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txconf),
            "::",
            stringify!(tx_free_thresh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_deferred_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txconf),
            "::",
            stringify!(tx_deferred_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offloads) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txconf),
            "::",
            stringify!(offloads)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved_64s) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txconf),
            "::",
            stringify!(reserved_64s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved_ptrs) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_txconf),
            "::",
            stringify!(reserved_ptrs)
        )
    );
}
#[doc = " A structure contains information about HW descriptor ring limitations."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_desc_lim {
    #[doc = "< Max allowed number of descriptors."]
    pub nb_max: u16,
    #[doc = "< Min allowed number of descriptors."]
    pub nb_min: u16,
    #[doc = "< Number of descriptors should be aligned to."]
    pub nb_align: u16,
    #[doc = " Max allowed number of segments per whole packet.\n\n - For TSO packet this is the total number of data descriptors allowed\n   by device.\n\n @see nb_mtu_seg_max"]
    pub nb_seg_max: u16,
    #[doc = " Max number of segments per one MTU.\n\n - For non-TSO packet, this is the maximum allowed number of segments\n   in a single transmit packet.\n\n - For TSO packet each segment within the TSO may span up to this\n   value.\n\n @see nb_seg_max"]
    pub nb_mtu_seg_max: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_desc_lim() {
    const UNINIT: ::std::mem::MaybeUninit<rte_eth_desc_lim> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_eth_desc_lim>(),
        10usize,
        concat!("Size of: ", stringify!(rte_eth_desc_lim))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_desc_lim>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_desc_lim))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_max) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_desc_lim),
            "::",
            stringify!(nb_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_min) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_desc_lim),
            "::",
            stringify!(nb_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_align) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_desc_lim),
            "::",
            stringify!(nb_align)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_seg_max) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_desc_lim),
            "::",
            stringify!(nb_seg_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_mtu_seg_max) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_desc_lim),
            "::",
            stringify!(nb_mtu_seg_max)
        )
    );
}
#[doc = " A structure describing a memzone, which is a contiguous portion of\n physical memory identified by a name."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_memzone {
    #[doc = "< Name of the memory zone."]
    pub name: [::std::os::raw::c_char; 32usize],
    #[doc = "< Start IO address."]
    pub iova: rte_iova_t,
    pub __bindgen_anon_1: rte_memzone__bindgen_ty_1,
    #[doc = "< Length of the memzone."]
    pub len: usize,
    #[doc = "< The page size of underlying memory"]
    pub hugepage_sz: u64,
    #[doc = "< NUMA socket ID."]
    pub socket_id: i32,
    #[doc = "< Characteristics of this memzone."]
    pub flags: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_memzone__bindgen_ty_1 {
    #[doc = "< Start virtual address."]
    pub addr: *mut ::std::os::raw::c_void,
    #[doc = "< Makes sure addr is always 64-bits"]
    pub addr_64: u64,
}
#[test]
fn bindgen_test_layout_rte_memzone__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<rte_memzone__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_memzone__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_memzone__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_memzone__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_memzone__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone__bindgen_ty_1),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr_64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone__bindgen_ty_1),
            "::",
            stringify!(addr_64)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_memzone() {
    const UNINIT: ::std::mem::MaybeUninit<rte_memzone> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_memzone>(),
        72usize,
        concat!("Size of: ", stringify!(rte_memzone))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_memzone>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_memzone))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iova) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone),
            "::",
            stringify!(iova)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hugepage_sz) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone),
            "::",
            stringify!(hugepage_sz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).socket_id) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone),
            "::",
            stringify!(socket_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone),
            "::",
            stringify!(flags)
        )
    );
}
#[doc = " A structure that stores a per-core object cache."]
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_cache {
    #[doc = "< Size of the cache"]
    pub size: u32,
    #[doc = "< Threshold before we flush excess elements"]
    pub flushthresh: u32,
    #[doc = "< Current cache count"]
    pub len: u32,
    pub __bindgen_padding_0: [u64; 6usize],
    #[doc = " Cache objects\n\n Cache is allocated to this size to allow it to overflow in certain\n cases to avoid needless emptying of cache."]
    pub objs: [*mut ::std::os::raw::c_void; 1024usize],
}
#[test]
fn bindgen_test_layout_rte_mempool_cache() {
    const UNINIT: ::std::mem::MaybeUninit<rte_mempool_cache> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_cache>(),
        8256usize,
        concat!("Size of: ", stringify!(rte_mempool_cache))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_cache>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_mempool_cache))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_cache),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flushthresh) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_cache),
            "::",
            stringify!(flushthresh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_cache),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).objs) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_cache),
            "::",
            stringify!(objs)
        )
    );
}
#[doc = " Mempool object header structure\n\n Each object stored in mempools are prefixed by this header structure,\n it allows to retrieve the mempool pointer from the object and to\n iterate on all objects attached to a mempool. When debug is enabled,\n a cookie is also added in this structure preventing corruptions and\n double-frees."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_objhdr {
    #[doc = "< Next in list."]
    pub next: rte_mempool_objhdr__bindgen_ty_1,
    #[doc = "< The mempool owning the object."]
    pub mp: *mut rte_mempool,
    #[doc = "< IO address of the object."]
    pub iova: rte_iova_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_objhdr__bindgen_ty_1 {
    pub stqe_next: *mut rte_mempool_objhdr,
}
#[test]
fn bindgen_test_layout_rte_mempool_objhdr__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<rte_mempool_objhdr__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_objhdr__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mempool_objhdr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_objhdr__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mempool_objhdr__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stqe_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objhdr__bindgen_ty_1),
            "::",
            stringify!(stqe_next)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_mempool_objhdr() {
    const UNINIT: ::std::mem::MaybeUninit<rte_mempool_objhdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_objhdr>(),
        24usize,
        concat!("Size of: ", stringify!(rte_mempool_objhdr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_objhdr>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mempool_objhdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objhdr),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objhdr),
            "::",
            stringify!(mp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iova) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objhdr),
            "::",
            stringify!(iova)
        )
    );
}
#[doc = " A list of object headers type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_objhdr_list {
    pub stqh_first: *mut rte_mempool_objhdr,
    pub stqh_last: *mut *mut rte_mempool_objhdr,
}
#[test]
fn bindgen_test_layout_rte_mempool_objhdr_list() {
    const UNINIT: ::std::mem::MaybeUninit<rte_mempool_objhdr_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_objhdr_list>(),
        16usize,
        concat!("Size of: ", stringify!(rte_mempool_objhdr_list))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_objhdr_list>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mempool_objhdr_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stqh_first) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objhdr_list),
            "::",
            stringify!(stqh_first)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stqh_last) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objhdr_list),
            "::",
            stringify!(stqh_last)
        )
    );
}
#[doc = " A list of memory where objects are stored"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_memhdr_list {
    pub stqh_first: *mut rte_mempool_memhdr,
    pub stqh_last: *mut *mut rte_mempool_memhdr,
}
#[test]
fn bindgen_test_layout_rte_mempool_memhdr_list() {
    const UNINIT: ::std::mem::MaybeUninit<rte_mempool_memhdr_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_memhdr_list>(),
        16usize,
        concat!("Size of: ", stringify!(rte_mempool_memhdr_list))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_memhdr_list>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mempool_memhdr_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stqh_first) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr_list),
            "::",
            stringify!(stqh_first)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stqh_last) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr_list),
            "::",
            stringify!(stqh_last)
        )
    );
}
#[doc = " Callback used to free a memory chunk"]
pub type rte_mempool_memchunk_free_cb_t = ::std::option::Option<
    unsafe extern "C" fn(memhdr: *mut rte_mempool_memhdr, opaque: *mut ::std::os::raw::c_void),
>;
#[doc = " Mempool objects memory header structure\n\n The memory chunks where objects are stored. Each chunk is virtually\n and physically contiguous."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_memhdr {
    #[doc = "< Next in list."]
    pub next: rte_mempool_memhdr__bindgen_ty_1,
    #[doc = "< The mempool owning the chunk"]
    pub mp: *mut rte_mempool,
    #[doc = "< Virtual address of the chunk"]
    pub addr: *mut ::std::os::raw::c_void,
    #[doc = "< IO address of the chunk"]
    pub iova: rte_iova_t,
    #[doc = "< length of the chunk"]
    pub len: usize,
    #[doc = "< Free callback"]
    pub free_cb: rte_mempool_memchunk_free_cb_t,
    #[doc = "< Argument passed to the free callback"]
    pub opaque: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_memhdr__bindgen_ty_1 {
    pub stqe_next: *mut rte_mempool_memhdr,
}
#[test]
fn bindgen_test_layout_rte_mempool_memhdr__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<rte_mempool_memhdr__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_memhdr__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mempool_memhdr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_memhdr__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mempool_memhdr__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stqe_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr__bindgen_ty_1),
            "::",
            stringify!(stqe_next)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_mempool_memhdr() {
    const UNINIT: ::std::mem::MaybeUninit<rte_mempool_memhdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_memhdr>(),
        56usize,
        concat!("Size of: ", stringify!(rte_mempool_memhdr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_memhdr>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mempool_memhdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr),
            "::",
            stringify!(mp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iova) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr),
            "::",
            stringify!(iova)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free_cb) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr),
            "::",
            stringify!(free_cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr),
            "::",
            stringify!(opaque)
        )
    );
}
#[doc = " The RTE mempool structure."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_mempool {
    #[doc = "< Name of mempool."]
    pub name: [::std::os::raw::c_char; 26usize],
    pub __bindgen_anon_1: rte_mempool__bindgen_ty_1,
    #[doc = "< optional args for ops alloc."]
    pub pool_config: *mut ::std::os::raw::c_void,
    #[doc = "< Memzone where pool is alloc'd."]
    pub mz: *const rte_memzone,
    #[doc = "< Flags of the mempool."]
    pub flags: ::std::os::raw::c_uint,
    #[doc = "< Socket id passed at create."]
    pub socket_id: ::std::os::raw::c_int,
    #[doc = "< Max size of the mempool."]
    pub size: u32,
    pub cache_size: u32,
    #[doc = "< Size of an element."]
    pub elt_size: u32,
    #[doc = "< Size of header (before elt)."]
    pub header_size: u32,
    #[doc = "< Size of trailer (after elt)."]
    pub trailer_size: u32,
    #[doc = "< Size of private data."]
    pub private_data_size: ::std::os::raw::c_uint,
    #[doc = " Index into rte_mempool_ops_table array of mempool ops\n structs, which contain callback function pointers.\n We're using an index here rather than pointers to the callbacks\n to facilitate any secondary processes that may want to use\n this mempool."]
    pub ops_index: i32,
    #[doc = "< Per-lcore local cache"]
    pub local_cache: *mut rte_mempool_cache,
    #[doc = "< Number of populated objects."]
    pub populated_size: u32,
    #[doc = "< List of objects in pool"]
    pub elt_list: rte_mempool_objhdr_list,
    #[doc = "< Number of memory chunks"]
    pub nb_mem_chunks: u32,
    #[doc = "< List of memory chunks"]
    pub mem_list: rte_mempool_memhdr_list,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mempool__bindgen_ty_1 {
    #[doc = "< Ring or pool to store objects."]
    pub pool_data: *mut ::std::os::raw::c_void,
    #[doc = "< External mempool identifier."]
    pub pool_id: u64,
}
#[test]
fn bindgen_test_layout_rte_mempool__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<rte_mempool__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_mempool__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mempool__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mempool__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pool_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool__bindgen_ty_1),
            "::",
            stringify!(pool_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pool_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool__bindgen_ty_1),
            "::",
            stringify!(pool_id)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_mempool() {
    const UNINIT: ::std::mem::MaybeUninit<rte_mempool> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_mempool>(),
        192usize,
        concat!("Size of: ", stringify!(rte_mempool))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_mempool))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pool_config) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(pool_config)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mz) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(mz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).socket_id) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(socket_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cache_size) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(cache_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).elt_size) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(elt_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header_size) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(header_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trailer_size) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(trailer_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_data_size) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(private_data_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ops_index) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(ops_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_cache) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(local_cache)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).populated_size) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(populated_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).elt_list) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(elt_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_mem_chunks) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(nb_mem_chunks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mem_list) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(mem_list)
        )
    );
}
extern "C" {
    #[doc = " Free a mempool\n\n Unlink the mempool from global list, free the memory chunks, and all\n memory referenced by the mempool. The objects must not be used by\n other cores as they will be freed.\n\n @param mp\n   A pointer to the mempool structure.\n   If NULL then, the function does nothing."]
    pub fn rte_mempool_free(mp: *mut rte_mempool);
}
extern "C" {
    #[doc = " Return the number of entries in the mempool.\n\n When cache is enabled, this function has to browse the length of\n all lcores, so it should not be used in a data path, but only for\n debug purposes. User-owned mempool caches are not accounted for.\n\n @param mp\n   A pointer to the mempool structure.\n @return\n   The number of entries in the mempool."]
    pub fn rte_mempool_avail_count(mp: *const rte_mempool) -> ::std::os::raw::c_uint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mbuf_sched {
    #[doc = "< Queue ID."]
    pub queue_id: u32,
    pub traffic_class: u8,
    pub color: u8,
    #[doc = "< Reserved."]
    pub reserved: u16,
}
#[test]
fn bindgen_test_layout_rte_mbuf_sched() {
    const UNINIT: ::std::mem::MaybeUninit<rte_mbuf_sched> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf_sched>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mbuf_sched))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf_sched>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_mbuf_sched))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).queue_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf_sched),
            "::",
            stringify!(queue_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).traffic_class) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf_sched),
            "::",
            stringify!(traffic_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf_sched),
            "::",
            stringify!(color)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf_sched),
            "::",
            stringify!(reserved)
        )
    );
}
pub const RTE_MBUF_L2_LEN_BITS: _bindgen_ty_3 = 7;
pub const RTE_MBUF_L3_LEN_BITS: _bindgen_ty_3 = 9;
pub const RTE_MBUF_L4_LEN_BITS: _bindgen_ty_3 = 8;
pub const RTE_MBUF_TSO_SEGSZ_BITS: _bindgen_ty_3 = 16;
pub const RTE_MBUF_OUTL3_LEN_BITS: _bindgen_ty_3 = 9;
pub const RTE_MBUF_OUTL2_LEN_BITS: _bindgen_ty_3 = 7;
pub const RTE_MBUF_TXOFLD_UNUSED_BITS: _bindgen_ty_3 = 8;
pub const RTE_MBUF_L2_LEN_OFS: _bindgen_ty_3 = 0;
pub const RTE_MBUF_L3_LEN_OFS: _bindgen_ty_3 = 7;
pub const RTE_MBUF_L4_LEN_OFS: _bindgen_ty_3 = 16;
pub const RTE_MBUF_TSO_SEGSZ_OFS: _bindgen_ty_3 = 24;
pub const RTE_MBUF_OUTL3_LEN_OFS: _bindgen_ty_3 = 40;
pub const RTE_MBUF_OUTL2_LEN_OFS: _bindgen_ty_3 = 49;
pub const RTE_MBUF_TXOFLD_UNUSED_OFS: _bindgen_ty_3 = 56;
#[doc = " enum for the tx_offload bit-fields lengths and offsets.\n defines the layout of rte_mbuf tx_offload field."]
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
#[doc = " The generic rte_mbuf, containing a packet mbuf."]
#[repr(C)]
#[repr(align(64))]
pub struct rte_mbuf {
    pub cacheline0: RTE_MARKER,
    #[doc = "< Virtual address of segment buffer."]
    pub buf_addr: *mut ::std::os::raw::c_void,
    #[doc = " Physical address of segment buffer.\n This field is undefined if the build is configured to use only\n virtual address as IOVA (i.e. RTE_IOVA_IN_MBUF is 0).\n Force alignment to 8-bytes, so as to ensure we have the exact\n same mbuf cacheline0 layout for 32-bit and 64-bit. This makes\n working on vector drivers easier."]
    pub buf_iova: rte_iova_t,
    pub rearm_data: RTE_MARKER64,
    pub data_off: u16,
    #[doc = " Reference counter. Its size should at least equal to the size\n of port field (16 bits), to support zero-copy broadcast.\n It should only be accessed using the following functions:\n rte_mbuf_refcnt_update(), rte_mbuf_refcnt_read(), and\n rte_mbuf_refcnt_set(). The functionality of these functions (atomic,\n or non-atomic) is controlled by the RTE_MBUF_REFCNT_ATOMIC flag."]
    pub refcnt: u16,
    #[doc = " Number of segments. Only valid for the first segment of an mbuf\n chain."]
    pub nb_segs: u16,
    #[doc = " Input port (16 bits to support more than 256 virtual ports).\n The event eth Tx adapter uses this field to specify the output port."]
    pub port: u16,
    #[doc = "< Offload features."]
    pub ol_flags: u64,
    pub rx_descriptor_fields1: RTE_MARKER,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_1,
    #[doc = "< Total pkt len: sum of all segments."]
    pub pkt_len: u32,
    #[doc = "< Amount of data in segment buffer."]
    pub data_len: u16,
    #[doc = " VLAN TCI (CPU order), valid if RTE_MBUF_F_RX_VLAN is set."]
    pub vlan_tci: u16,
    pub __bindgen_anon_2: rte_mbuf__bindgen_ty_2,
    #[doc = " Outer VLAN TCI (CPU order), valid if RTE_MBUF_F_RX_QINQ is set."]
    pub vlan_tci_outer: u16,
    #[doc = "< Length of segment buffer."]
    pub buf_len: u16,
    #[doc = "< Pool from which mbuf was allocated."]
    pub pool: *mut rte_mempool,
    pub cacheline1: RTE_MARKER,
    #[doc = " Next segment of scattered packet. Must be NULL in the last\n segment or in case of non-segmented packet."]
    pub next: *mut rte_mbuf,
    pub __bindgen_anon_3: rte_mbuf__bindgen_ty_3,
    #[doc = " Shared data for external buffer attached to mbuf. See\n rte_pktmbuf_attach_extbuf()."]
    pub shinfo: *mut rte_mbuf_ext_shared_info,
    #[doc = " Size of the application private data. In case of an indirect\n mbuf, it stores the direct mbuf private data size."]
    pub priv_size: u16,
    #[doc = " Timesync flags for use with IEEE1588."]
    pub timesync: u16,
    #[doc = "< Reserved for dynamic fields."]
    pub dynfield1: [u32; 9usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_1 {
    #[doc = "< L2/L3/L4 and tunnel information."]
    pub packet_type: u32,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub inner_esp_next_proto: u8,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn inner_l2_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_inner_l2_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn inner_l3_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_inner_l3_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        inner_l2_type: u8,
        inner_l3_type: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let inner_l2_type: u8 = unsafe { ::std::mem::transmute(inner_l2_type) };
            inner_l2_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let inner_l3_type: u8 = unsafe { ::std::mem::transmute(inner_l3_type) };
            inner_l3_type as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inner_esp_next_proto) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(inner_esp_next_proto)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl rte_mbuf__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn l2_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_l2_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn l3_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_l3_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn l4_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_l4_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn tun_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_tun_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        l2_type: u8,
        l3_type: u8,
        l4_type: u8,
        tun_type: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let l2_type: u8 = unsafe { ::std::mem::transmute(l2_type) };
            l2_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let l3_type: u8 = unsafe { ::std::mem::transmute(l3_type) };
            l3_type as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let l4_type: u8 = unsafe { ::std::mem::transmute(l4_type) };
            l4_type as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let tun_type: u8 = unsafe { ::std::mem::transmute(tun_type) };
            tun_type as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn inner_l4_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_inner_l4_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(inner_l4_type: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let inner_l4_type: u8 = unsafe { ::std::mem::transmute(inner_l4_type) };
            inner_l4_type as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<rte_mbuf__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(rte_mbuf__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_mbuf__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).packet_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_1),
            "::",
            stringify!(packet_type)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2 {
    #[doc = "< hash information"]
    pub hash: rte_mbuf__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2__bindgen_ty_1 {
    #[doc = "< RSS hash result if RSS enabled"]
    pub rss: u32,
    #[doc = "< Filter identifier if FDIR enabled"]
    pub fdir: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    pub sched: rte_mbuf_sched,
    #[doc = "< Eventdev ethdev Tx adapter"]
    pub txadapter: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2,
    pub usr: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub hi: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1:
        rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub lo: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub hash: u16,
    pub id: u16,
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1(
) {
    const UNINIT: ::std::mem::MaybeUninit<
        rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<
            rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(
                rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        >(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(
                rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            ),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(
                rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            ),
            "::",
            stringify!(id)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(lo)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hi) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(hi)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {
    pub reserved1: u32,
    pub reserved2: u16,
    pub txq: u16,
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).txq) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(txq)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_2__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<rte_mbuf__bindgen_ty_2__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rss) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(rss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fdir) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(fdir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sched) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(sched)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).txadapter) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(txadapter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).usr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(usr)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<rte_mbuf__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mbuf__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_mbuf__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_2),
            "::",
            stringify!(hash)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_3 {
    #[doc = "< combined for easy fetch"]
    pub tx_offload: u64,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 7usize]>,
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_3__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_1)
        )
    );
}
impl rte_mbuf__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn l2_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u64) }
    }
    #[inline]
    pub fn set_l2_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn l3_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 9u8) as u64) }
    }
    #[inline]
    pub fn set_l3_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn l4_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_l4_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn tso_segsz(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_tso_segsz(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn outer_l3_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 9u8) as u64) }
    }
    #[inline]
    pub fn set_outer_l3_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn outer_l2_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(49usize, 7u8) as u64) }
    }
    #[inline]
    pub fn set_outer_l2_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(49usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        l2_len: u64,
        l3_len: u64,
        l4_len: u64,
        tso_segsz: u64,
        outer_l3_len: u64,
        outer_l2_len: u64,
    ) -> __BindgenBitfieldUnit<[u8; 7usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 7usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let l2_len: u64 = unsafe { ::std::mem::transmute(l2_len) };
            l2_len as u64
        });
        __bindgen_bitfield_unit.set(7usize, 9u8, {
            let l3_len: u64 = unsafe { ::std::mem::transmute(l3_len) };
            l3_len as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let l4_len: u64 = unsafe { ::std::mem::transmute(l4_len) };
            l4_len as u64
        });
        __bindgen_bitfield_unit.set(24usize, 16u8, {
            let tso_segsz: u64 = unsafe { ::std::mem::transmute(tso_segsz) };
            tso_segsz as u64
        });
        __bindgen_bitfield_unit.set(40usize, 9u8, {
            let outer_l3_len: u64 = unsafe { ::std::mem::transmute(outer_l3_len) };
            outer_l3_len as u64
        });
        __bindgen_bitfield_unit.set(49usize, 7u8, {
            let outer_l2_len: u64 = unsafe { ::std::mem::transmute(outer_l2_len) };
            outer_l2_len as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<rte_mbuf__bindgen_ty_3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_3>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mbuf__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mbuf__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_offload) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_3),
            "::",
            stringify!(tx_offload)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_mbuf() {
    const UNINIT: ::std::mem::MaybeUninit<rte_mbuf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf>(),
        128usize,
        concat!("Size of: ", stringify!(rte_mbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_mbuf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cacheline0) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(cacheline0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(buf_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf_iova) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(buf_iova)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rearm_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(rearm_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_off) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(data_off)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refcnt) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(refcnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_segs) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(nb_segs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ol_flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(ol_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_descriptor_fields1) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(rx_descriptor_fields1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pkt_len) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(pkt_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_len) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(data_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vlan_tci) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(vlan_tci)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vlan_tci_outer) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(vlan_tci_outer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf_len) as usize - ptr as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(buf_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pool) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cacheline1) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(cacheline1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shinfo) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(shinfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_size) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(priv_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timesync) as usize - ptr as usize },
        90usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(timesync)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynfield1) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(dynfield1)
        )
    );
}
#[doc = " Function typedef of callback to free externally attached buffer."]
pub type rte_mbuf_extbuf_free_callback_t = ::std::option::Option<
    unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void, opaque: *mut ::std::os::raw::c_void),
>;
#[doc = " Shared data at the end of an external buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mbuf_ext_shared_info {
    #[doc = "< Free callback function"]
    pub free_cb: rte_mbuf_extbuf_free_callback_t,
    #[doc = "< Free callback argument"]
    pub fcb_opaque: *mut ::std::os::raw::c_void,
    pub refcnt: u16,
}
#[test]
fn bindgen_test_layout_rte_mbuf_ext_shared_info() {
    const UNINIT: ::std::mem::MaybeUninit<rte_mbuf_ext_shared_info> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf_ext_shared_info>(),
        24usize,
        concat!("Size of: ", stringify!(rte_mbuf_ext_shared_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf_ext_shared_info>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mbuf_ext_shared_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free_cb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf_ext_shared_info),
            "::",
            stringify!(free_cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fcb_opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf_ext_shared_info),
            "::",
            stringify!(fcb_opaque)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refcnt) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf_ext_shared_info),
            "::",
            stringify!(refcnt)
        )
    );
}
extern "C" {
    #[doc = " Create a mbuf pool.\n\n This function creates and initializes a packet mbuf pool. It is\n a wrapper to rte_mempool functions.\n\n @param name\n   The name of the mbuf pool.\n @param n\n   The number of elements in the mbuf pool. The optimum size (in terms\n   of memory usage) for a mempool is when n is a power of two minus one:\n   n = (2^q - 1).\n @param cache_size\n   Size of the per-core object cache. See rte_mempool_create() for\n   details.\n @param priv_size\n   Size of application private are between the rte_mbuf structure\n   and the data buffer. This value must be aligned to RTE_MBUF_PRIV_ALIGN.\n @param data_room_size\n   Size of data buffer in each mbuf, including RTE_PKTMBUF_HEADROOM.\n @param socket_id\n   The socket identifier where the memory should be allocated. The\n   value can be *SOCKET_ID_ANY* if there is no NUMA constraint for the\n   reserved zone.\n @return\n   The pointer to the new allocated mempool, on success. NULL on error\n   with rte_errno set appropriately. Possible rte_errno values include:\n    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure\n    - EINVAL - cache size provided is too large, or priv_size is not aligned.\n    - ENOSPC - the maximum number of memzones has already been allocated\n    - EEXIST - a memzone with the same name already exists\n    - ENOMEM - no appropriate memory area found in which to create memzone"]
    pub fn rte_pktmbuf_pool_create(
        name: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_uint,
        cache_size: ::std::os::raw::c_uint,
        priv_size: u16,
        data_room_size: u16,
        socket_id: ::std::os::raw::c_int,
    ) -> *mut rte_mempool;
}
extern "C" {
    #[doc = " Free a bulk of packet mbufs back into their original mempools.\n\n Free a bulk of mbufs, and all their segments in case of chained buffers.\n Each segment is added back into its original mempool.\n\n  @param mbufs\n    Array of pointers to packet mbufs.\n    The array may contain NULL pointers.\n  @param count\n    Array size."]
    pub fn rte_pktmbuf_free_bulk(mbufs: *mut *mut rte_mbuf, count: ::std::os::raw::c_uint);
}
#[doc = " Ethernet address:\n A universally administered address is uniquely assigned to a device by its\n manufacturer. The first three octets (in transmission order) contain the\n Organizationally Unique Identifier (OUI). The following three (MAC-48 and\n EUI-48) octets are assigned by that organization with the only constraint\n of uniqueness.\n A locally administered address is assigned to a device by a network\n administrator and does not contain OUIs.\n See http://standards.ieee.org/regauth/groupmac/tutorial.html"]
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct rte_ether_addr {
    #[doc = "< Addr bytes in tx order"]
    pub addr_bytes: [u8; 6usize],
}
#[test]
fn bindgen_test_layout_rte_ether_addr() {
    const UNINIT: ::std::mem::MaybeUninit<rte_ether_addr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_ether_addr>(),
        6usize,
        concat!("Size of: ", stringify!(rte_ether_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_ether_addr>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_ether_addr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr_bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ether_addr),
            "::",
            stringify!(addr_bytes)
        )
    );
}
#[doc = " A structure used to enable/disable specific device interrupts."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_intr_conf {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_rte_eth_intr_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_intr_conf>(),
        4usize,
        concat!("Size of: ", stringify!(rte_eth_intr_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_intr_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_intr_conf))
    );
}
impl rte_eth_intr_conf {
    #[inline]
    pub fn lsc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lsc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rxq(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rxq(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rmv(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rmv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(lsc: u32, rxq: u32, rmv: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let lsc: u32 = unsafe { ::std::mem::transmute(lsc) };
            lsc as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let rxq: u32 = unsafe { ::std::mem::transmute(rxq) };
            rxq as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let rmv: u32 = unsafe { ::std::mem::transmute(rmv) };
            rmv as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " A structure used to configure an Ethernet port.\n Depending upon the Rx multi-queue mode, extra advanced\n configuration settings may be needed."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_conf {
    #[doc = "< bitmap of RTE_ETH_LINK_SPEED_XXX of speeds to be\nused. RTE_ETH_LINK_SPEED_FIXED disables link\nautonegotiation, and a unique speed shall be\nset. Otherwise, the bitmap defines the set of\nspeeds to be advertised. If the special value\nRTE_ETH_LINK_SPEED_AUTONEG (0) is used, all speeds\nsupported are advertised."]
    pub link_speeds: u32,
    #[doc = "< Port Rx configuration."]
    pub rxmode: rte_eth_rxmode,
    #[doc = "< Port Tx configuration."]
    pub txmode: rte_eth_txmode,
    #[doc = "< Loopback operation mode. By default the value\nis 0, meaning the loopback mode is disabled.\nRead the datasheet of given Ethernet controller\nfor details. The possible values of this field\nare defined in implementation of each driver."]
    pub lpbk_mode: u32,
    #[doc = "< Port Rx filtering configuration."]
    pub rx_adv_conf: rte_eth_conf__bindgen_ty_1,
    #[doc = "< Port Tx DCB configuration (union)."]
    pub tx_adv_conf: rte_eth_conf__bindgen_ty_2,
    #[doc = " Currently,Priority Flow Control(PFC) are supported,if DCB with PFC\nis needed,and the variable must be set RTE_ETH_DCB_PFC_SUPPORT."]
    pub dcb_capability_en: u32,
    #[doc = "< Interrupt mode configuration."]
    pub intr_conf: rte_eth_intr_conf,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_conf__bindgen_ty_1 {
    #[doc = "< Port RSS configuration"]
    pub rss_conf: rte_eth_rss_conf,
    #[doc = " Port VMDq+DCB configuration."]
    pub vmdq_dcb_conf: rte_eth_vmdq_dcb_conf,
    #[doc = " Port DCB Rx configuration."]
    pub dcb_rx_conf: rte_eth_dcb_rx_conf,
    #[doc = " Port VMDq Rx configuration."]
    pub vmdq_rx_conf: rte_eth_vmdq_rx_conf,
}
#[test]
fn bindgen_test_layout_rte_eth_conf__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<rte_eth_conf__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_eth_conf__bindgen_ty_1>(),
        2128usize,
        concat!("Size of: ", stringify!(rte_eth_conf__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_conf__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_conf__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rss_conf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf__bindgen_ty_1),
            "::",
            stringify!(rss_conf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vmdq_dcb_conf) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf__bindgen_ty_1),
            "::",
            stringify!(vmdq_dcb_conf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dcb_rx_conf) as usize - ptr as usize },
        1072usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf__bindgen_ty_1),
            "::",
            stringify!(dcb_rx_conf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vmdq_rx_conf) as usize - ptr as usize },
        1088usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf__bindgen_ty_1),
            "::",
            stringify!(vmdq_rx_conf)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_conf__bindgen_ty_2 {
    #[doc = " Port VMDq+DCB Tx configuration."]
    pub vmdq_dcb_tx_conf: rte_eth_vmdq_dcb_tx_conf,
    #[doc = " Port DCB Tx configuration."]
    pub dcb_tx_conf: rte_eth_dcb_tx_conf,
    #[doc = " Port VMDq Tx configuration."]
    pub vmdq_tx_conf: rte_eth_vmdq_tx_conf,
}
#[test]
fn bindgen_test_layout_rte_eth_conf__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<rte_eth_conf__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_eth_conf__bindgen_ty_2>(),
        12usize,
        concat!("Size of: ", stringify!(rte_eth_conf__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_conf__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_conf__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vmdq_dcb_tx_conf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf__bindgen_ty_2),
            "::",
            stringify!(vmdq_dcb_tx_conf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dcb_tx_conf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf__bindgen_ty_2),
            "::",
            stringify!(dcb_tx_conf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vmdq_tx_conf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf__bindgen_ty_2),
            "::",
            stringify!(vmdq_tx_conf)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_eth_conf() {
    const UNINIT: ::std::mem::MaybeUninit<rte_eth_conf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_eth_conf>(),
        2280usize,
        concat!("Size of: ", stringify!(rte_eth_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_conf>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_conf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).link_speeds) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(link_speeds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rxmode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(rxmode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).txmode) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(txmode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lpbk_mode) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(lpbk_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_adv_conf) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(rx_adv_conf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_adv_conf) as usize - ptr as usize },
        2256usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(tx_adv_conf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dcb_capability_en) as usize - ptr as usize },
        2268usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(dcb_capability_en)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).intr_conf) as usize - ptr as usize },
        2272usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_conf),
            "::",
            stringify!(intr_conf)
        )
    );
}
#[doc = " Preferred Rx/Tx port parameters.\n There are separate instances of this structure for transmission\n and reception respectively."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dev_portconf {
    #[doc = "< Device-preferred burst size"]
    pub burst_size: u16,
    #[doc = "< Device-preferred size of queue rings"]
    pub ring_size: u16,
    #[doc = "< Device-preferred number of queues"]
    pub nb_queues: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_dev_portconf() {
    const UNINIT: ::std::mem::MaybeUninit<rte_eth_dev_portconf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dev_portconf>(),
        6usize,
        concat!("Size of: ", stringify!(rte_eth_dev_portconf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dev_portconf>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_eth_dev_portconf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).burst_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_portconf),
            "::",
            stringify!(burst_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ring_size) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_portconf),
            "::",
            stringify!(ring_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_queues) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_portconf),
            "::",
            stringify!(nb_queues)
        )
    );
}
#[doc = " Ethernet device associated switch information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_switch_info {
    #[doc = "< switch name"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< switch domain ID"]
    pub domain_id: u16,
    #[doc = " Mapping to the devices physical switch port as enumerated from the\n perspective of the embedded interconnect/switch. For SR-IOV enabled\n device this may correspond to the VF_ID of each virtual function,\n but each driver should explicitly define the mapping of switch\n port identifier to that physical interconnect/switch"]
    pub port_id: u16,
    #[doc = " Shared Rx queue sub-domain boundary. Only ports in same Rx domain\n and switch domain can share Rx queue. Valid only if device advertised\n RTE_ETH_DEV_CAPA_RXQ_SHARE capability."]
    pub rx_domain: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_switch_info() {
    const UNINIT: ::std::mem::MaybeUninit<rte_eth_switch_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_eth_switch_info>(),
        16usize,
        concat!("Size of: ", stringify!(rte_eth_switch_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_switch_info>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_switch_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_switch_info),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).domain_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_switch_info),
            "::",
            stringify!(domain_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port_id) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_switch_info),
            "::",
            stringify!(port_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_domain) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_switch_info),
            "::",
            stringify!(rx_domain)
        )
    );
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice.\n\n Ethernet device Rx buffer segmentation capabilities."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_rxseg_capa {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Maximum amount of segments to split."]
    pub max_nseg: u16,
    #[doc = "< Reserved field."]
    pub reserved: u16,
}
#[test]
fn bindgen_test_layout_rte_eth_rxseg_capa() {
    const UNINIT: ::std::mem::MaybeUninit<rte_eth_rxseg_capa> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_eth_rxseg_capa>(),
        8usize,
        concat!("Size of: ", stringify!(rte_eth_rxseg_capa))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_rxseg_capa>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_eth_rxseg_capa))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_nseg) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxseg_capa),
            "::",
            stringify!(max_nseg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_rxseg_capa),
            "::",
            stringify!(reserved)
        )
    );
}
impl rte_eth_rxseg_capa {
    #[inline]
    pub fn multi_pools(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_multi_pools(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn offset_allowed(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_offset_allowed(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn offset_align_log2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_offset_align_log2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        multi_pools: u32,
        offset_allowed: u32,
        offset_align_log2: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let multi_pools: u32 = unsafe { ::std::mem::transmute(multi_pools) };
            multi_pools as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let offset_allowed: u32 = unsafe { ::std::mem::transmute(offset_allowed) };
            offset_allowed as u64
        });
        __bindgen_bitfield_unit.set(2usize, 4u8, {
            let offset_align_log2: u32 = unsafe { ::std::mem::transmute(offset_align_log2) };
            offset_align_log2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " No error handling modes are supported."]
pub const rte_eth_err_handle_mode_RTE_ETH_ERROR_HANDLE_MODE_NONE: rte_eth_err_handle_mode = 0;
#[doc = " Passive error handling, after the PMD detects that a reset is required,\n the PMD reports @see RTE_ETH_EVENT_INTR_RESET event,\n and the application invokes @see rte_eth_dev_reset to recover the port."]
pub const rte_eth_err_handle_mode_RTE_ETH_ERROR_HANDLE_MODE_PASSIVE: rte_eth_err_handle_mode = 1;
#[doc = " Proactive error handling, after the PMD detects that a reset is required,\n the PMD reports @see RTE_ETH_EVENT_ERR_RECOVERING event,\n do recovery internally, and finally reports the recovery result event\n (@see RTE_ETH_EVENT_RECOVERY_*)."]
pub const rte_eth_err_handle_mode_RTE_ETH_ERROR_HANDLE_MODE_PROACTIVE: rte_eth_err_handle_mode = 2;
#[doc = " @warning\n @b EXPERIMENTAL: this enumeration may change without prior notice.\n\n Ethernet device error handling mode."]
pub type rte_eth_err_handle_mode = ::std::os::raw::c_uint;
#[doc = " A structure used to retrieve the contextual information of\n an Ethernet device, such as the controlling driver of the\n device, etc..."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dev_info {
    #[doc = "< Generic device information"]
    pub device: *mut rte_device,
    #[doc = "< Device Driver name."]
    pub driver_name: *const ::std::os::raw::c_char,
    #[doc = "< Index to bound host interface, or 0 if none.\nUse if_indextoname() to translate into an interface name."]
    pub if_index: ::std::os::raw::c_uint,
    #[doc = "< Minimum MTU allowed"]
    pub min_mtu: u16,
    #[doc = "< Maximum MTU allowed"]
    pub max_mtu: u16,
    #[doc = "< Device flags"]
    pub dev_flags: *const u32,
    #[doc = " Minimum Rx buffer size per descriptor supported by HW."]
    pub min_rx_bufsize: u32,
    #[doc = " Maximum Rx buffer size per descriptor supported by HW.\n The value is not enforced, information only to application to\n optimize mbuf size.\n Its value is UINT32_MAX when not specified by the driver."]
    pub max_rx_bufsize: u32,
    #[doc = "< Maximum configurable length of Rx pkt."]
    pub max_rx_pktlen: u32,
    #[doc = " Maximum configurable size of LRO aggregated packet."]
    pub max_lro_pkt_size: u32,
    #[doc = "< Maximum number of Rx queues."]
    pub max_rx_queues: u16,
    #[doc = "< Maximum number of Tx queues."]
    pub max_tx_queues: u16,
    #[doc = "< Maximum number of MAC addresses."]
    pub max_mac_addrs: u32,
    #[doc = " Maximum number of hash MAC addresses for MTA and UTA."]
    pub max_hash_mac_addrs: u32,
    #[doc = "< Maximum number of VFs."]
    pub max_vfs: u16,
    #[doc = "< Maximum number of VMDq pools."]
    pub max_vmdq_pools: u16,
    #[doc = "< Segmentation capability."]
    pub rx_seg_capa: rte_eth_rxseg_capa,
    #[doc = " All Rx offload capabilities including all per-queue ones"]
    pub rx_offload_capa: u64,
    #[doc = " All Tx offload capabilities including all per-queue ones"]
    pub tx_offload_capa: u64,
    #[doc = " Device per-queue Rx offload capabilities."]
    pub rx_queue_offload_capa: u64,
    #[doc = " Device per-queue Tx offload capabilities."]
    pub tx_queue_offload_capa: u64,
    #[doc = " Device redirection table size, the total number of entries."]
    pub reta_size: u16,
    #[doc = "< Hash key size in bytes"]
    pub hash_key_size: u8,
    pub rss_algo_capa: u32,
    #[doc = " RSS hash algorithms capabilities */\n/** Bit mask of RSS offloads, the bit offset also means flow type"]
    pub flow_type_rss_offloads: u64,
    #[doc = "< Default Rx configuration"]
    pub default_rxconf: rte_eth_rxconf,
    #[doc = "< Default Tx configuration"]
    pub default_txconf: rte_eth_txconf,
    #[doc = "< First queue ID for VMDq pools."]
    pub vmdq_queue_base: u16,
    #[doc = "< Queue number for VMDq pools."]
    pub vmdq_queue_num: u16,
    #[doc = "< First ID of VMDq pools."]
    pub vmdq_pool_base: u16,
    #[doc = "< Rx descriptors limits"]
    pub rx_desc_lim: rte_eth_desc_lim,
    #[doc = "< Tx descriptors limits"]
    pub tx_desc_lim: rte_eth_desc_lim,
    #[doc = "< Supported speeds bitmap (RTE_ETH_LINK_SPEED_)."]
    pub speed_capa: u32,
    #[doc = "< Number of Rx queues."]
    pub nb_rx_queues: u16,
    #[doc = "< Number of Tx queues."]
    pub nb_tx_queues: u16,
    #[doc = " Maximum number of Rx mempools supported per Rx queue.\n\n Value greater than 0 means that the driver supports Rx queue\n mempools specification via rx_conf->rx_mempools."]
    pub max_rx_mempools: u16,
    #[doc = " Rx parameter recommendations"]
    pub default_rxportconf: rte_eth_dev_portconf,
    #[doc = " Tx parameter recommendations"]
    pub default_txportconf: rte_eth_dev_portconf,
    #[doc = " Generic device capabilities (RTE_ETH_DEV_CAPA_)."]
    pub dev_capa: u64,
    #[doc = " Switching information for ports on a device with a\n embedded managed interconnect/switch."]
    pub switch_info: rte_eth_switch_info,
    #[doc = " Supported error handling mode."]
    pub err_handle_mode: rte_eth_err_handle_mode,
    #[doc = "< Reserved for future fields"]
    pub reserved_64s: [u64; 2usize],
    #[doc = "< Reserved for future fields"]
    pub reserved_ptrs: [*mut ::std::os::raw::c_void; 2usize],
}
#[test]
fn bindgen_test_layout_rte_eth_dev_info() {
    const UNINIT: ::std::mem::MaybeUninit<rte_eth_dev_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_eth_dev_info>(),
        376usize,
        concat!("Size of: ", stringify!(rte_eth_dev_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_dev_info>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_dev_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).driver_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(driver_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).if_index) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(if_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_mtu) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(min_mtu)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_mtu) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_mtu)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dev_flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(dev_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_rx_bufsize) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(min_rx_bufsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_rx_bufsize) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_rx_bufsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_rx_pktlen) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_rx_pktlen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_lro_pkt_size) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_lro_pkt_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_rx_queues) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_rx_queues)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_tx_queues) as usize - ptr as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_tx_queues)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_mac_addrs) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_mac_addrs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_hash_mac_addrs) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_hash_mac_addrs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_vfs) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_vfs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_vmdq_pools) as usize - ptr as usize },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_vmdq_pools)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_seg_capa) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(rx_seg_capa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_offload_capa) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(rx_offload_capa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_offload_capa) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(tx_offload_capa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_queue_offload_capa) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(rx_queue_offload_capa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_queue_offload_capa) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(tx_queue_offload_capa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reta_size) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(reta_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash_key_size) as usize - ptr as usize },
        106usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(hash_key_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rss_algo_capa) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(rss_algo_capa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flow_type_rss_offloads) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(flow_type_rss_offloads)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_rxconf) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(default_rxconf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_txconf) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(default_txconf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vmdq_queue_base) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(vmdq_queue_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vmdq_queue_num) as usize - ptr as usize },
        258usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(vmdq_queue_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vmdq_pool_base) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(vmdq_pool_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_desc_lim) as usize - ptr as usize },
        262usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(rx_desc_lim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_desc_lim) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(tx_desc_lim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).speed_capa) as usize - ptr as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(speed_capa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_rx_queues) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(nb_rx_queues)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_tx_queues) as usize - ptr as usize },
        290usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(nb_tx_queues)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_rx_mempools) as usize - ptr as usize },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(max_rx_mempools)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_rxportconf) as usize - ptr as usize },
        294usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(default_rxportconf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_txportconf) as usize - ptr as usize },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(default_txportconf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dev_capa) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(dev_capa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).switch_info) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(switch_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).err_handle_mode) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(err_handle_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved_64s) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(reserved_64s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved_ptrs) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_eth_dev_info),
            "::",
            stringify!(reserved_ptrs)
        )
    );
}
extern "C" {
    #[doc = " Get the number of ports which are usable for the application.\n\n These devices must be iterated by using the macro\n ``RTE_ETH_FOREACH_DEV`` or ``RTE_ETH_FOREACH_DEV_OWNED_BY``\n to deal with non-contiguous ranges of devices.\n\n @return\n   The count of available Ethernet devices."]
    pub fn rte_eth_dev_count_avail() -> u16;
}
extern "C" {
    #[doc = " Configure an Ethernet device.\n This function must be invoked first before any other function in the\n Ethernet API. This function can also be re-invoked when a device is in the\n stopped state.\n\n @param port_id\n   The port identifier of the Ethernet device to configure.\n @param nb_rx_queue\n   The number of receive queues to set up for the Ethernet device.\n @param nb_tx_queue\n   The number of transmit queues to set up for the Ethernet device.\n @param eth_conf\n   The pointer to the configuration data to be used for the Ethernet device.\n   The *rte_eth_conf* structure includes:\n     -  the hardware offload features to activate, with dedicated fields for\n        each statically configurable offload hardware feature provided by\n        Ethernet devices, such as IP checksum or VLAN tag stripping for\n        example.\n        The Rx offload bitfield API is obsolete and will be deprecated.\n        Applications should set the ignore_bitfield_offloads bit on *rxmode*\n        structure and use offloads field to set per-port offloads instead.\n     -  Any offloading set in eth_conf->[rt]xmode.offloads must be within\n        the [rt]x_offload_capa returned from rte_eth_dev_info_get().\n        Any type of device supported offloading set in the input argument\n        eth_conf->[rt]xmode.offloads to rte_eth_dev_configure() is enabled\n        on all queues and it can't be disabled in rte_eth_[rt]x_queue_setup()\n     -  the Receive Side Scaling (RSS) configuration when using multiple Rx\n        queues per port. Any RSS hash function set in eth_conf->rss_conf.rss_hf\n        must be within the flow_type_rss_offloads provided by drivers via\n        rte_eth_dev_info_get() API.\n\n   Embedding all configuration information in a single data structure\n   is the more flexible method that allows the addition of new features\n   without changing the syntax of the API.\n @return\n   - 0: Success, device configured.\n   - <0: Error code returned by the driver configuration function."]
    pub fn rte_eth_dev_configure(
        port_id: u16,
        nb_rx_queue: u16,
        nb_tx_queue: u16,
        eth_conf: *const rte_eth_conf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate and set up a receive queue for an Ethernet device.\n\n The function allocates a contiguous block of memory for *nb_rx_desc*\n receive descriptors from a memory zone associated with *socket_id*\n and initializes each receive descriptor with a network buffer allocated\n from the memory pool *mb_pool*.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param rx_queue_id\n   The index of the receive queue to set up.\n   The value must be in the range [0, nb_rx_queue - 1] previously supplied\n   to rte_eth_dev_configure().\n @param nb_rx_desc\n   The number of receive descriptors to allocate for the receive ring.\n @param socket_id\n   The *socket_id* argument is the socket identifier in case of NUMA.\n   The value can be *SOCKET_ID_ANY* if there is no NUMA constraint for\n   the DMA memory allocated for the receive descriptors of the ring.\n @param rx_conf\n   The pointer to the configuration data to be used for the receive queue.\n   NULL value is allowed, in which case default Rx configuration\n   will be used.\n   The *rx_conf* structure contains an *rx_thresh* structure with the values\n   of the Prefetch, Host, and Write-Back threshold registers of the receive\n   ring.\n   In addition it contains the hardware offloads features to activate using\n   the RTE_ETH_RX_OFFLOAD_* flags.\n   If an offloading set in rx_conf->offloads\n   hasn't been set in the input argument eth_conf->rxmode.offloads\n   to rte_eth_dev_configure(), it is a new added offloading, it must be\n   per-queue type and it is enabled for the queue.\n   No need to repeat any bit in rx_conf->offloads which has already been\n   enabled in rte_eth_dev_configure() at port level. An offloading enabled\n   at port level can't be disabled at queue level.\n   The configuration structure also contains the pointer to the array\n   of the receiving buffer segment descriptions, see rx_seg and rx_nseg\n   fields, this extended configuration might be used by split offloads like\n   RTE_ETH_RX_OFFLOAD_BUFFER_SPLIT. If mb_pool is not NULL,\n   the extended configuration fields must be set to NULL and zero.\n @param mb_pool\n   The pointer to the memory pool from which to allocate *rte_mbuf* network\n   memory buffers to populate each descriptor of the receive ring. There are\n   two options to provide Rx buffer configuration:\n   - single pool:\n     mb_pool is not NULL, rx_conf.rx_nseg is 0.\n   - multiple segments description:\n     mb_pool is NULL, rx_conf.rx_seg is not NULL, rx_conf.rx_nseg is not 0.\n     Taken only if flag RTE_ETH_RX_OFFLOAD_BUFFER_SPLIT is set in offloads.\n\n @return\n   - 0: Success, receive queue correctly set up.\n   - -EIO: if device is removed.\n   - -ENODEV: if *port_id* is invalid.\n   - -EINVAL: The memory pool pointer is null or the size of network buffers\n      which can be allocated from this memory pool does not fit the various\n      buffer sizes allowed by the device controller.\n   - -ENOMEM: Unable to allocate the receive ring descriptors or to\n      allocate network memory buffers from the memory pool when\n      initializing receive descriptors."]
    pub fn rte_eth_rx_queue_setup(
        port_id: u16,
        rx_queue_id: u16,
        nb_rx_desc: u16,
        socket_id: ::std::os::raw::c_uint,
        rx_conf: *const rte_eth_rxconf,
        mb_pool: *mut rte_mempool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate and set up a transmit queue for an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param tx_queue_id\n   The index of the transmit queue to set up.\n   The value must be in the range [0, nb_tx_queue - 1] previously supplied\n   to rte_eth_dev_configure().\n @param nb_tx_desc\n   The number of transmit descriptors to allocate for the transmit ring.\n @param socket_id\n   The *socket_id* argument is the socket identifier in case of NUMA.\n   Its value can be *SOCKET_ID_ANY* if there is no NUMA constraint for\n   the DMA memory allocated for the transmit descriptors of the ring.\n @param tx_conf\n   The pointer to the configuration data to be used for the transmit queue.\n   NULL value is allowed, in which case default Tx configuration\n   will be used.\n   The *tx_conf* structure contains the following data:\n   - The *tx_thresh* structure with the values of the Prefetch, Host, and\n     Write-Back threshold registers of the transmit ring.\n     When setting Write-Back threshold to the value greater then zero,\n     *tx_rs_thresh* value should be explicitly set to one.\n   - The *tx_free_thresh* value indicates the [minimum] number of network\n     buffers that must be pending in the transmit ring to trigger their\n     [implicit] freeing by the driver transmit function.\n   - The *tx_rs_thresh* value indicates the [minimum] number of transmit\n     descriptors that must be pending in the transmit ring before setting the\n     RS bit on a descriptor by the driver transmit function.\n     The *tx_rs_thresh* value should be less or equal then\n     *tx_free_thresh* value, and both of them should be less then\n     *nb_tx_desc* - 3.\n   - The *offloads* member contains Tx offloads to be enabled.\n     If an offloading set in tx_conf->offloads\n     hasn't been set in the input argument eth_conf->txmode.offloads\n     to rte_eth_dev_configure(), it is a new added offloading, it must be\n     per-queue type and it is enabled for the queue.\n     No need to repeat any bit in tx_conf->offloads which has already been\n     enabled in rte_eth_dev_configure() at port level. An offloading enabled\n     at port level can't be disabled at queue level.\n\n     Note that setting *tx_free_thresh* or *tx_rs_thresh* value to 0 forces\n     the transmit function to use default values.\n @return\n   - 0: Success, the transmit queue is correctly set up.\n   - -ENOMEM: Unable to allocate the transmit ring descriptors."]
    pub fn rte_eth_tx_queue_setup(
        port_id: u16,
        tx_queue_id: u16,
        nb_tx_desc: u16,
        socket_id: ::std::os::raw::c_uint,
        tx_conf: *const rte_eth_txconf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the NUMA socket to which an Ethernet device is connected\n\n @param port_id\n   The port identifier of the Ethernet device\n @return\n   - The NUMA socket ID which the Ethernet device is connected to.\n   - -1 (which translates to SOCKET_ID_ANY) if the socket could not be\n     determined. rte_errno is then set to:\n     - EINVAL is the port_id is invalid,\n     - 0 is the socket could not be determined,"]
    pub fn rte_eth_dev_socket_id(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Start an Ethernet device.\n\n The device start step is the last one and consists of setting the configured\n offload features and in starting the transmit and the receive units of the\n device.\n\n Device RTE_ETH_DEV_NOLIVE_MAC_ADDR flag causes MAC address to be set before\n PMD port start callback function is invoked.\n\n All device queues (except form deferred start queues) status should be\n `RTE_ETH_QUEUE_STATE_STARTED` after start.\n\n On success, all basic functions exported by the Ethernet API (link status,\n receive/transmit, and so on) can be invoked.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @return\n   - 0: Success, Ethernet device started.\n   - -EAGAIN: If start operation must be retried.\n   - <0: Error code of the driver device start function."]
    pub fn rte_eth_dev_start(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Stop an Ethernet device. The device can be restarted with a call to\n rte_eth_dev_start()\n\n All device queues status should be `RTE_ETH_QUEUE_STATE_STOPPED` after stop.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @return\n   - 0: Success, Ethernet device stopped.\n   - -EBUSY: If stopping the port is not allowed in current state.\n   - <0: Error code of the driver device stop function."]
    pub fn rte_eth_dev_stop(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Close a stopped Ethernet device. The device cannot be restarted!\n The function frees all port resources.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @return\n   - Zero if the port is closed successfully.\n   - Negative if something went wrong."]
    pub fn rte_eth_dev_close(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enable receipt in promiscuous mode for an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if support for promiscuous_enable() does not exist\n     for the device.\n   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_promiscuous_enable(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Disable receipt in promiscuous mode for an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if support for promiscuous_disable() does not exist\n     for the device.\n   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_promiscuous_disable(port_id: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the general I/O statistics of an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param stats\n   A pointer to a structure of type *rte_eth_stats* to be filled with\n   the values of device counters for the following set of statistics:\n   - *ipackets* with the total of successfully received packets.\n   - *opackets* with the total of successfully transmitted packets.\n   - *ibytes*   with the total of successfully received bytes.\n   - *obytes*   with the total of successfully transmitted bytes.\n   - *ierrors*  with the total of erroneous received packets.\n   - *oerrors*  with the total of failed transmitted packets.\n @return\n   Zero if successful. Non-zero otherwise."]
    pub fn rte_eth_stats_get(port_id: u16, stats: *mut rte_eth_stats) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the Ethernet address of an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param mac_addr\n   A pointer to a structure of type *ether_addr* to be filled with\n   the Ethernet address of the Ethernet device.\n @return\n   - (0) if successful\n   - (-ENODEV) if *port_id* invalid.\n   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_macaddr_get(
        port_id: u16,
        mac_addr: *mut rte_ether_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the contextual information of an Ethernet device.\n\n This function returns the Ethernet device information based\n on the values stored internally in the device specific data.\n For example: number of queues, descriptor limits, device\n capabilities and offload flags.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param dev_info\n   A pointer to a structure of type *rte_eth_dev_info* to be filled with\n   the contextual information of the Ethernet device.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if support for dev_infos_get() does not exist for the device.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_dev_info_get(
        port_id: u16,
        dev_info: *mut rte_eth_dev_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_lcore_id_() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rte_mempool_full_(mp: *const rte_mempool) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_pktmbuf_alloc_(mp: *mut rte_mempool) -> *mut rte_mbuf;
}
extern "C" {
    pub fn rte_pktmbuf_alloc_bulk_(
        pool: *mut rte_mempool,
        mbufs: *mut *mut rte_mbuf,
        count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_pktmbuf_free_(m: *mut rte_mbuf);
}
extern "C" {
    pub fn rte_eth_rx_burst_(
        port_id: u16,
        queue_id: u16,
        rx_pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
    ) -> u16;
}
extern "C" {
    pub fn rte_eth_tx_burst_(
        port_id: u16,
        queue_id: u16,
        tx_pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
    ) -> u16;
}
extern "C" {
    pub fn rte_errno_() -> ::std::os::raw::c_int;
}
