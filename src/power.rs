/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[doc = " Callback definition for monitoring conditions. Callbacks with this signature\n will be used by `rte_power_monitor()` to check if the entering of power\n optimized state should be aborted.\n\n @param val\n   The value read from memory.\n @param opaque\n   Callback-specific data.\n\n @return\n   0 if entering of power optimized state should proceed\n   -1 if entering of power optimized state should be aborted"]
pub type rte_power_monitor_clb_t = ::std::option::Option<
    unsafe extern "C" fn(val: u64, opaque: *const u64) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_power_monitor_cond {
    #[doc = "< Address to monitor for changes"]
    pub addr: *mut ::std::os::raw::c_void,
    #[doc = "< Data size (in bytes) that will be read from the\n   monitored memory location (`addr`). Can be 1, 2,\n   4, or 8. Supplying any other value will result in\n   an error."]
    pub size: u8,
    #[doc = "< Callback to be used to check if\n   entering power optimized state should\n   be aborted."]
    pub fn_: rte_power_monitor_clb_t,
    pub opaque: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_rte_power_monitor_cond() {
    const UNINIT: ::std::mem::MaybeUninit<rte_power_monitor_cond> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_power_monitor_cond>(),
        56usize,
        concat!("Size of: ", stringify!(rte_power_monitor_cond))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_power_monitor_cond>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_power_monitor_cond))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_power_monitor_cond),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_power_monitor_cond),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fn_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_power_monitor_cond),
            "::",
            stringify!(fn_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_power_monitor_cond),
            "::",
            stringify!(opaque)
        )
    );
}
extern "C" {
    #[doc = " Monitor specific address for changes. This will cause the CPU to enter an\n architecture-defined optimized power state until either the specified\n memory address is written to, a certain TSC timestamp is reached, or other\n reasons cause the CPU to wake up.\n\n Additionally, an expected value (`pmc->val`), mask (`pmc->mask`), and data\n size (`pmc->size`) are provided in the `pmc` power monitoring condition. If\n the mask is non-zero, the current value pointed to by the `pmc->addr` pointer\n will be read and compared against the expected value, and if they match, the\n entering of optimized power state will be aborted. This is intended to\n prevent the CPU from entering optimized power state and waiting on a write\n that has already happened by the time this API is called.\n\n @warning It is responsibility of the user to check if this function is\n   supported at runtime using `rte_cpu_get_intrinsics_support()` API call.\n\n @param pmc\n   The monitoring condition structure.\n @param tsc_timestamp\n   Maximum TSC timestamp to wait for. Note that the wait behavior is\n   architecture-dependent.\n\n @return\n   0 on success\n   -EINVAL on invalid parameters\n   -ENOTSUP if unsupported"]
    pub fn rte_power_monitor(
        pmc: *const rte_power_monitor_cond,
        tsc_timestamp: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Wake up a specific lcore that is in a power optimized state and is monitoring\n an address.\n\n @note It is safe to call this function if the lcore in question is not\n   sleeping. The function will have no effect.\n\n @note This function will *not* wake up a core that is in a power optimized\n   state due to calling `rte_power_pause`.\n\n @param lcore_id\n   Lcore ID of a sleeping thread."]
    pub fn rte_power_monitor_wakeup(lcore_id: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enter an architecture-defined optimized power state until a certain TSC\n timestamp is reached.\n\n @warning It is responsibility of the user to check if this function is\n   supported at runtime using `rte_cpu_get_intrinsics_support()` API call.\n\n @param tsc_timestamp\n   Maximum TSC timestamp to wait for. Note that the wait behavior is\n   architecture-dependent.\n\n @return\n   0 on success\n   -EINVAL on invalid parameters\n   -ENOTSUP if unsupported"]
    pub fn rte_power_pause(tsc_timestamp: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Monitor a set of addresses for changes. This will cause the CPU to enter an\n architecture-defined optimized power state until either one of the specified\n memory addresses is written to, a certain TSC timestamp is reached, or other\n reasons cause the CPU to wake up.\n\n Additionally, `expected` 64-bit values and 64-bit masks are provided. If\n mask is non-zero, the current value pointed to by the `p` pointer will be\n checked against the expected value, and if they do not match, the entering of\n optimized power state may be aborted.\n\n @warning It is responsibility of the user to check if this function is\n   supported at runtime using `rte_cpu_get_intrinsics_support()` API call.\n   Failing to do so may result in an illegal CPU instruction error.\n\n @param pmc\n   An array of monitoring condition structures.\n @param num\n   Length of the `pmc` array.\n @param tsc_timestamp\n   Maximum TSC timestamp to wait for. Note that the wait behavior is\n   architecture-dependent.\n\n @return\n   0 on success\n   -EINVAL on invalid parameters\n   -ENOTSUP if unsupported"]
    pub fn rte_power_monitor_multi(
        pmc: *const rte_power_monitor_cond,
        num: u32,
        tsc_timestamp: u64,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_power_traffic_policy {
    pub min_packet_thresh: u32,
    pub avg_max_packet_thresh: u32,
    pub max_max_packet_thresh: u32,
}
#[test]
fn bindgen_test_layout_rte_power_traffic_policy() {
    const UNINIT: ::std::mem::MaybeUninit<rte_power_traffic_policy> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_power_traffic_policy>(),
        12usize,
        concat!("Size of: ", stringify!(rte_power_traffic_policy))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_power_traffic_policy>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_power_traffic_policy))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_packet_thresh) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_power_traffic_policy),
            "::",
            stringify!(min_packet_thresh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).avg_max_packet_thresh) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_power_traffic_policy),
            "::",
            stringify!(avg_max_packet_thresh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_max_packet_thresh) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_power_traffic_policy),
            "::",
            stringify!(max_max_packet_thresh)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_power_timer_profile {
    pub busy_hours: [::std::os::raw::c_int; 24usize],
    pub quiet_hours: [::std::os::raw::c_int; 24usize],
    pub hours_to_use_traffic_profile: [::std::os::raw::c_int; 24usize],
}
#[test]
fn bindgen_test_layout_rte_power_timer_profile() {
    const UNINIT: ::std::mem::MaybeUninit<rte_power_timer_profile> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_power_timer_profile>(),
        288usize,
        concat!("Size of: ", stringify!(rte_power_timer_profile))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_power_timer_profile>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_power_timer_profile))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).busy_hours) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_power_timer_profile),
            "::",
            stringify!(busy_hours)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quiet_hours) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_power_timer_profile),
            "::",
            stringify!(quiet_hours)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).hours_to_use_traffic_profile) as usize - ptr as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_power_timer_profile),
            "::",
            stringify!(hours_to_use_traffic_profile)
        )
    );
}
pub const rte_power_workload_level_RTE_POWER_WL_HIGH: rte_power_workload_level = 0;
pub const rte_power_workload_level_RTE_POWER_WL_MEDIUM: rte_power_workload_level = 1;
pub const rte_power_workload_level_RTE_POWER_WL_LOW: rte_power_workload_level = 2;
pub type rte_power_workload_level = ::std::os::raw::c_uint;
pub const rte_power_policy_RTE_POWER_POLICY_TRAFFIC: rte_power_policy = 0;
pub const rte_power_policy_RTE_POWER_POLICY_TIME: rte_power_policy = 1;
pub const rte_power_policy_RTE_POWER_POLICY_WORKLOAD: rte_power_policy = 2;
pub const rte_power_policy_RTE_POWER_POLICY_BRANCH_RATIO: rte_power_policy = 3;
pub type rte_power_policy = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_power_turbo_status {
    pub tbEnabled: bool,
}
#[test]
fn bindgen_test_layout_rte_power_turbo_status() {
    const UNINIT: ::std::mem::MaybeUninit<rte_power_turbo_status> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_power_turbo_status>(),
        1usize,
        concat!("Size of: ", stringify!(rte_power_turbo_status))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_power_turbo_status>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_power_turbo_status))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tbEnabled) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_power_turbo_status),
            "::",
            stringify!(tbEnabled)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_power_channel_packet {
    #[doc = "< core_num, device"]
    pub resource_id: u64,
    #[doc = "< scale down/up/min/max"]
    pub unit: u32,
    #[doc = "< Power, IO, etc"]
    pub command: u32,
    pub vm_name: [::std::os::raw::c_char; 32usize],
    pub vfid: [u64; 10usize],
    pub nb_mac_to_monitor: ::std::os::raw::c_int,
    pub traffic_policy: rte_power_traffic_policy,
    pub vcpu_to_control: [u8; 8usize],
    pub num_vcpu: u8,
    pub timer_policy: rte_power_timer_profile,
    pub core_type: bool,
    pub workload: rte_power_workload_level,
    pub policy_to_use: rte_power_policy,
    pub t_boost_status: rte_power_turbo_status,
}
#[test]
fn bindgen_test_layout_rte_power_channel_packet() {
    const UNINIT: ::std::mem::MaybeUninit<rte_power_channel_packet> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_power_channel_packet>(),
        464usize,
        concat!("Size of: ", stringify!(rte_power_channel_packet))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_power_channel_packet>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_power_channel_packet))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resource_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_power_channel_packet),
            "::",
            stringify!(resource_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unit) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_power_channel_packet),
            "::",
            stringify!(unit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).command) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_power_channel_packet),
            "::",
            stringify!(command)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vm_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_power_channel_packet),
            "::",
            stringify!(vm_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vfid) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_power_channel_packet),
            "::",
            stringify!(vfid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_mac_to_monitor) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_power_channel_packet),
            "::",
            stringify!(nb_mac_to_monitor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).traffic_policy) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_power_channel_packet),
            "::",
            stringify!(traffic_policy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vcpu_to_control) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_power_channel_packet),
            "::",
            stringify!(vcpu_to_control)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_vcpu) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_power_channel_packet),
            "::",
            stringify!(num_vcpu)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timer_policy) as usize - ptr as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_power_channel_packet),
            "::",
            stringify!(timer_policy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).core_type) as usize - ptr as usize },
        444usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_power_channel_packet),
            "::",
            stringify!(core_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).workload) as usize - ptr as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_power_channel_packet),
            "::",
            stringify!(workload)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).policy_to_use) as usize - ptr as usize },
        452usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_power_channel_packet),
            "::",
            stringify!(policy_to_use)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t_boost_status) as usize - ptr as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_power_channel_packet),
            "::",
            stringify!(t_boost_status)
        )
    );
}
extern "C" {
    #[doc = " Send a message contained in pkt over the Virtio-Serial to the host endpoint.\n\n @param pkt\n  Pointer to a populated struct channel_packet.\n\n @param lcore_id\n  Use channel specific to this lcore_id.\n\n @return\n  - 0 on success.\n  - Negative on error."]
    pub fn rte_power_guest_channel_send_msg(
        pkt: *mut rte_power_channel_packet,
        lcore_id: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Receive a message contained in pkt over the Virtio-Serial\n from the host endpoint.\n\n @param pkt\n  Pointer to channel_packet or\n  channel_packet_freq_list struct.\n\n @param pkt_len\n  Size of expected data packet.\n\n @param lcore_id\n  Use channel specific to this lcore_id.\n\n @return\n  - 0 on success.\n  - Negative on error."]
    pub fn rte_power_guest_channel_receive_msg(
        pkt: *mut ::std::os::raw::c_void,
        pkt_len: usize,
        lcore_id: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub const power_management_env_PM_ENV_NOT_SET: power_management_env = 0;
pub const power_management_env_PM_ENV_ACPI_CPUFREQ: power_management_env = 1;
pub const power_management_env_PM_ENV_KVM_VM: power_management_env = 2;
pub const power_management_env_PM_ENV_PSTATE_CPUFREQ: power_management_env = 3;
pub const power_management_env_PM_ENV_CPPC_CPUFREQ: power_management_env = 4;
pub const power_management_env_PM_ENV_AMD_PSTATE_CPUFREQ: power_management_env = 5;
pub type power_management_env = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Check if a specific power management environment type is supported on a\n currently running system.\n\n @param env\n   The environment type to check support for.\n\n @return\n   - 1 if supported\n   - 0 if unsupported\n   - -1 if error, with rte_errno indicating reason for error."]
    pub fn rte_power_check_env_supported(env: power_management_env) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the default power management implementation. If this is not called prior\n to rte_power_init(), then auto-detect of the environment will take place.\n It is thread safe. New env can be set only in uninitialized state\n (thus rte_power_unset_env must be called if different env was already set).\n\n @param env\n  env. The environment in which to initialise Power Management for.\n\n @return\n  - 0 on success.\n  - Negative on error."]
    pub fn rte_power_set_env(env: power_management_env) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Unset the global environment configuration.\n This can only be called after all threads have completed."]
    pub fn rte_power_unset_env();
}
extern "C" {
    #[doc = " Get the default power management implementation.\n\n @return\n  power_management_env The configured environment."]
    pub fn rte_power_get_env() -> power_management_env;
}
extern "C" {
    #[doc = " Initialize power management for a specific lcore. If rte_power_set_env() has\n not been called then an auto-detect of the environment will start and\n initialise the corresponding resources.\n\n @param lcore_id\n  lcore id.\n\n @return\n  - 0 on success.\n  - Negative on error."]
    pub fn rte_power_init(lcore_id: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Exit power management on a specific lcore. This will call the environment\n dependent exit function.\n\n @param lcore_id\n  lcore id.\n\n @return\n  - 0 on success.\n  - Negative on error."]
    pub fn rte_power_exit(lcore_id: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
#[doc = " Power capabilities summary."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_power_core_capabilities {
    pub __bindgen_anon_1: rte_power_core_capabilities__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_power_core_capabilities__bindgen_ty_1 {
    pub capabilities: u64,
    pub __bindgen_anon_1: rte_power_core_capabilities__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct rte_power_core_capabilities__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_rte_power_core_capabilities__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_power_core_capabilities__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(rte_power_core_capabilities__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_power_core_capabilities__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rte_power_core_capabilities__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl rte_power_core_capabilities__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn turbo(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_turbo(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn priority(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_priority(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(turbo: u64, priority: u64) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let turbo: u64 = unsafe { ::std::mem::transmute(turbo) };
            turbo as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let priority: u64 = unsafe { ::std::mem::transmute(priority) };
            priority as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_rte_power_core_capabilities__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<rte_power_core_capabilities__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_power_core_capabilities__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(rte_power_core_capabilities__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_power_core_capabilities__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rte_power_core_capabilities__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capabilities) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_power_core_capabilities__bindgen_ty_1),
            "::",
            stringify!(capabilities)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_power_core_capabilities() {
    assert_eq!(
        ::std::mem::size_of::<rte_power_core_capabilities>(),
        8usize,
        concat!("Size of: ", stringify!(rte_power_core_capabilities))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_power_core_capabilities>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_power_core_capabilities))
    );
}
